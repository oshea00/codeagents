{
    "architecture_plan": "**Problem Analysis**\n\nYou need a command-line calculator that operates in a REPL (Read-Eval-Print Loop), supporting:\n- Scientific functions (trigonometric, factorial, exponential)\n- Binary and logic operations\n- Correct operator precedence (including unary minus with special rules)\n- Variable assignment and usage\n- Command line history (arrow key navigation)\n- In-REPL help facility\n\nThe calculator must parse and evaluate complex expressions, handle edge cases (like multiple unary minuses), and provide a user-friendly CLI experience.\n\n---\n\n**Requirements**\n\n1. **REPL Loop**\n   - Continuously prompt for user input until exit command.\n   - Print results or errors.\n\n2. **Expression Parsing & Evaluation**\n   - Support arithmetic: `+`, `-`, `*`, `/`\n   - Support scientific: `sin`, `cos`, `tan`, `exp`, `log`, `factorial`, etc.\n   - Support binary/logic: `&`, `|`, `^`, `~`, `<<`, `>>`\n   - Correct precedence: `*`/`/` > `+`/`-`; unary minus has highest precedence when consecutive.\n   - Handle negative literals and multiple unary minuses (e.g., `--3 == 3`).\n\n3. **Variable Assignment**\n   - Allow `x = 5`, then use `x` in expressions.\n\n4. **Command Line History**\n   - Up/down arrow navigation through previous commands.\n\n5. **Help Facility**\n   - `help` command prints usage and supported functions/operators.\n\n6. **Error Handling**\n   - Graceful handling of invalid input, undefined variables, math errors.\n\n---\n\n**Architecture Design**\n\n1. **Main Components**\n   - **REPL Engine**: Handles input/output, command history, and help.\n   - **Lexer/Tokenizer**: Converts input string into tokens.\n   - **Parser**: Builds an Abstract Syntax Tree (AST) from tokens, respecting precedence and associativity.\n   - **Evaluator**: Walks the AST, computes results, manages variables.\n   - **Symbol Table**: Stores variable assignments.\n   - **Function Library**: Implements scientific and logic functions.\n\n2. **Data Flow**\n   ```\n   User Input\n      \u2193\n   REPL Engine\n      \u2193\n   Tokenizer \u2192 Parser \u2192 AST \u2192 Evaluator \u2192 Result\n      \u2191\n   Symbol Table & Function Library\n   ```\n\n3. **Operator Precedence**\n   - Highest: Parentheses, function calls, unary minus (multiple allowed)\n   - Next: `*`, `/`\n   - Next: `+`, `-`\n   - Next: Binary/logic ops\n   - Left-to-right for equal precedence\n\n4. **Extensibility**\n   - New functions/operators can be added to the function library and parser.\n\n---\n\n**Development Plan**\n\n1. **Project Setup**\n   - Initialize project structure and version control.\n\n2. **REPL Engine**\n   - Implement input loop, output, and exit command.\n   - Integrate command line history (e.g., via `readline`).\n\n3. **Help Facility**\n   - Implement `help` command with usage and supported features.\n\n4. **Lexer/Tokenizer**\n   - Tokenize input, recognizing numbers, variables, operators, parentheses, functions.\n\n5. **Parser**\n   - Build AST, handle operator precedence, associativity, and multiple unary minuses.\n\n6. **Evaluator**\n   - Walk AST, compute results, handle errors.\n   - Implement variable assignment and lookup.\n\n7. **Function Library**\n   - Implement scientific and logic functions.\n\n8. **Symbol Table**\n   - Store and retrieve variable values.\n\n9. **Testing**\n   - Unit tests for parser, evaluator, and REPL.\n   - Manual testing for REPL usability.\n\n10. **Documentation**\n    - Usage instructions and help text.\n\n**Estimated Effort (for a single developer)**\n- Project setup: 0.5 day\n- REPL & history: 1 day\n- Help facility: 0.5 day\n- Tokenizer: 1 day\n- Parser: 2 days\n- Evaluator: 2 days\n- Function library: 1 day\n- Variable handling: 0.5 day\n- Testing & docs: 1.5 days\n- **Total: ~10 days**\n\n---\n\n**Technology Stack**\n\n- **Language**: Python 3.x (excellent for REPL, parsing, math, and CLI)\n- **CLI/REPL**: `readline` (for history), `cmd` (optional), or `prompt_toolkit` (for advanced CLI)\n- **Parsing**: Custom recursive descent parser or use `lark`/`pyparsing` for faster development\n- **Math**: Python `math` module, `operator` module for logic ops\n- **Testing**: `unittest` or `pytest`\n\n---\n\n**Risks and Mitigations**\n\n1. **Complex Expression Parsing**\n   - *Risk*: Handling all precedence and associativity, especially with multiple unary minuses.\n   - *Mitigation*: Write comprehensive unit tests for parser; consider using a parsing library if custom parser is too complex.\n\n2. **User Input Errors**\n   - *Risk*: Invalid expressions, undefined variables, math domain errors.\n   - *Mitigation*: Robust error handling and clear error messages.\n\n3. **Command Line Usability**\n   - *Risk*: History navigation may not work on all platforms.\n   - *Mitigation*: Use standard libraries (`readline`) and test on target platforms.\n\n4. **Extensibility**\n   - *Risk*: Hard to add new functions/operators later.\n   - *Mitigation*: Modular design for function/operator registration.\n\n5. **Performance**\n   - *Risk*: For very complex expressions, performance may degrade.\n   - *Mitigation*: For CLI calculator, this is usually acceptable.\n\n---\n\n**Summary Table**\n\n| Component         | Technology         | Key Tasks                                  |\n|-------------------|-------------------|--------------------------------------------|\n| REPL Engine       | Python, readline  | Input loop, history, help, exit            |\n| Tokenizer         | Python            | Tokenize input                             |\n| Parser            | Python            | Build AST, handle precedence               |\n| Evaluator         | Python            | Evaluate AST, manage variables             |\n| Function Library  | Python math       | Implement scientific/logic functions       |\n| Symbol Table      | Python dict       | Store variable assignments                 |\n| Testing           | unittest/pytest   | Unit and integration tests                 |\n\n---\n\n**Next Steps**\n\n1. Set up the project and basic REPL with history and help.\n2. Implement the tokenizer and parser with correct precedence rules.\n3. Add evaluator, function library, and variable support.\n4. Test thoroughly and refine usability.\n\nLet me know if you want a sample code skeleton or further breakdown of any component!",
    "implementation_history": [
        "```python\n# =============================================================================\n# Command-Line Scientific Calculator (REPL) with Variable Assignment, History,\n# Expression Parsing, Scientific/Logic Functions, and Help Facility\n#\n# Implementation Approach:\n# - Modular design: REPL Engine, Tokenizer, Parser (recursive descent), AST,\n#   Evaluator, Symbol Table, and Function Library.\n# - Uses Python's `readline` for command history and arrow navigation.\n# - Custom tokenizer and parser to handle operator precedence, associativity,\n#   unary minus, and function calls.\n# - Supports variable assignment and usage.\n# - Comprehensive error handling and in-REPL help.\n# - Easily extensible for new functions/operators.\n# =============================================================================\n\nimport math\nimport operator\nimport readline  # For command line history and arrow navigation\nimport sys\nimport re\n\n# =============================================================================\n# Function Library: Scientific and Logic Functions\n# =============================================================================\n\nclass FunctionLibrary:\n    \"\"\"\n    Provides a registry of supported scientific and logic functions.\n    \"\"\"\n    def __init__(self):\n        # Map function names to (callable, arity)\n        self.functions = {\n            'sin':   (math.sin, 1),\n            'cos':   (math.cos, 1),\n            'tan':   (math.tan, 1),\n            'asin':  (math.asin, 1),\n            'acos':  (math.acos, 1),\n            'atan':  (math.atan, 1),\n            'exp':   (math.exp, 1),\n            'log':   (math.log, 1),\n            'log10': (math.log10, 1),\n            'sqrt':  (math.sqrt, 1),\n            'abs':   (abs, 1),\n            'factorial': (math.factorial, 1),\n            'floor': (math.floor, 1),\n            'ceil':  (math.ceil, 1),\n            'round': (round, 1),\n            'deg':   (math.degrees, 1),\n            'rad':   (math.radians, 1),\n            # Logic/bitwise functions\n            'bin':   (bin, 1),\n            'hex':   (hex, 1),\n            'oct':   (oct, 1),\n        }\n\n    def is_function(self, name):\n        return name in self.functions\n\n    def call(self, name, args):\n        if name not in self.functions:\n            raise ValueError(f\"Unknown function: {name}\")\n        func, arity = self.functions[name]\n        if len(args) != arity:\n            raise ValueError(f\"Function '{name}' expects {arity} argument(s), got {len(args)}\")\n        return func(*args)\n\n    def list_functions(self):\n        return sorted(self.functions.keys())\n\n# =============================================================================\n# Symbol Table: Variable Assignment and Lookup\n# =============================================================================\n\nclass SymbolTable:\n    \"\"\"\n    Stores variable assignments and provides lookup.\n    \"\"\"\n    def __init__(self):\n        self.symbols = {\n            'pi': math.pi,\n            'e': math.e,\n            'tau': math.tau,\n        }\n\n    def set(self, name, value):\n        self.symbols[name] = value\n\n    def get(self, name):\n        if name not in self.symbols:\n            raise NameError(f\"Undefined variable: '{name}'\")\n        return self.symbols[name]\n\n    def list_symbols(self):\n        return {k: v for k, v in self.symbols.items() if not k.startswith('_')}\n\n# =============================================================================\n# Tokenizer (Lexer)\n# =============================================================================\n\n# Token types\nNUMBER      = 'NUMBER'\nIDENTIFIER  = 'IDENTIFIER'\nOPERATOR    = 'OPERATOR'\nLPAREN      = 'LPAREN'\nRPAREN      = 'RPAREN'\nCOMMA       = 'COMMA'\nASSIGN      = 'ASSIGN'\nEOF         = 'EOF'\n\n# Token specification (regex patterns)\nTOKEN_SPEC = [\n    (NUMBER,     r'\\d+(\\.\\d*)?([eE][-+]?\\d+)?'),  # Integer or decimal number\n    (IDENTIFIER, r'[A-Za-z_][A-Za-z0-9_]*'),      # Identifiers (variables/functions)\n    (OPERATOR,   r'==|!=|<=|>=|<<|>>|[+\\-*/&|^~<>]'),  # Operators\n    (ASSIGN,     r'='),                           # Assignment\n    (LPAREN,     r'\\('),                          # Left parenthesis\n    (RPAREN,     r'\\)'),                          # Right parenthesis\n    (COMMA,      r','),                           # Comma\n    ('SKIP',     r'[ \\t]+'),                      # Skip spaces/tabs\n    ('MISMATCH', r'.'),                           # Any other character\n]\n\nTOKEN_REGEX = '|'.join(f'(?P<{name}>{pattern})' for name, pattern in TOKEN_SPEC)\n\nclass Token:\n    \"\"\"\n    Represents a single token with type and value.\n    \"\"\"\n    def __init__(self, type_, value, position):\n        self.type = type_\n        self.value = value\n        self.position = position  # Position in input string\n\n    def __repr__(self):\n        return f\"Token({self.type}, {self.value}, pos={self.position})\"\n\nclass Tokenizer:\n    \"\"\"\n    Converts input string into a stream of tokens.\n    \"\"\"\n    def __init__(self, text):\n        self.text = text\n        self.tokens = []\n        self.pos = 0\n        self._tokenize()\n\n    def _tokenize(self):\n        for mo in re.finditer(TOKEN_REGEX, self.text):\n            kind = mo.lastgroup\n            value = mo.group()\n            pos = mo.start()\n            if kind == 'NUMBER':\n                value = float(value) if '.' in value or 'e' in value or 'E' in value else int(value)\n                self.tokens.append(Token(NUMBER, value, pos))\n            elif kind == 'IDENTIFIER':\n                self.tokens.append(Token(IDENTIFIER, value, pos))\n            elif kind == 'OPERATOR':\n                self.tokens.append(Token(OPERATOR, value, pos))\n            elif kind == 'ASSIGN':\n                self.tokens.append(Token(ASSIGN, value, pos))\n            elif kind == 'LPAREN':\n                self.tokens.append(Token(LPAREN, value, pos))\n            elif kind == 'RPAREN':\n                self.tokens.append(Token(RPAREN, value, pos))\n            elif kind == 'COMMA':\n                self.tokens.append(Token(COMMA, value, pos))\n            elif kind == 'SKIP':\n                continue\n            elif kind == 'MISMATCH':\n                raise SyntaxError(f\"Unexpected character '{value}' at position {pos}\")\n        self.tokens.append(Token(EOF, None, len(self.text)))\n\n    def peek(self):\n        return self.tokens[self.pos]\n\n    def next(self):\n        token = self.tokens[self.pos]\n        self.pos += 1\n        return token\n\n    def expect(self, type_, value=None):\n        token = self.peek()\n        if token.type != type_ or (value is not None and token.value != value):\n            raise SyntaxError(f\"Expected {type_} '{value}' at position {token.position}, got {token.type} '{token.value}'\")\n        return self.next()\n\n# =============================================================================\n# AST Node Definitions\n# =============================================================================\n\nclass ASTNode:\n    pass\n\nclass NumberNode(ASTNode):\n    def __init__(self, value):\n        self.value = value\n\nclass VariableNode(ASTNode):\n    def __init__(self, name):\n        self.name = name\n\nclass UnaryOpNode(ASTNode):\n    def __init__(self, op, operand):\n        self.op = op\n        self.operand = operand\n\nclass BinaryOpNode(ASTNode):\n    def __init__(self, left, op, right):\n        self.left = left\n        self.op = op\n        self.right = right\n\nclass AssignNode(ASTNode):\n    def __init__(self, name, expr):\n        self.name = name\n        self.expr = expr\n\nclass FunctionCallNode(ASTNode):\n    def __init__(self, name, args):\n        self.name = name\n        self.args = args\n\n# =============================================================================\n# Parser (Recursive Descent)\n# =============================================================================\n\nclass Parser:\n    \"\"\"\n    Builds an AST from tokens, handling precedence and associativity.\n    \"\"\"\n    def __init__(self, tokenizer, function_library):\n        self.tokens = tokenizer\n        self.function_library = function_library\n\n    def parse(self):\n        \"\"\"\n        Entry point: parse an assignment or expression.\n        \"\"\"\n        node = self.parse_assignment()\n        if self.tokens.peek().type != EOF:\n            raise SyntaxError(f\"Unexpected token '{self.tokens.peek().value}' at position {self.tokens.peek().position}\")\n        return node\n\n    def parse_assignment(self):\n        \"\"\"\n        assignment ::= IDENTIFIER '=' expression | expression\n        \"\"\"\n        token = self.tokens.peek()\n        if token.type == IDENTIFIER:\n            next_token = self.tokens.tokens[self.tokens.pos + 1]\n            if next_token.type == ASSIGN:\n                var_name = self.tokens.next().value\n                self.tokens.expect(ASSIGN)\n                expr = self.parse_expression()\n                return AssignNode(var_name, expr)\n        return self.parse_expression()\n\n    def parse_expression(self):\n        \"\"\"\n        Handles lowest precedence: bitwise OR '|'\n        \"\"\"\n        node = self.parse_bitwise_xor()\n        while self.tokens.peek().type == OPERATOR and self.tokens.peek().value == '|':\n            op = self.tokens.next().value\n            right = self.parse_bitwise_xor()\n            node = BinaryOpNode(node, op, right)\n        return node\n\n    def parse_bitwise_xor(self):\n        node = self.parse_bitwise_and()\n        while self.tokens.peek().type == OPERATOR and self.tokens.peek().value == '^':\n            op = self.tokens.next().value\n            right = self.parse_bitwise_and()\n            node = BinaryOpNode(node, op, right)\n        return node\n\n    def parse_bitwise_and(self):\n        node = self.parse_shift()\n        while self.tokens.peek().type == OPERATOR and self.tokens.peek().value == '&':\n            op = self.tokens.next().value\n            right = self.parse_shift()\n            node = BinaryOpNode(node, op, right)\n        return node\n\n    def parse_shift(self):\n        node = self.parse_add_sub()\n        while self.tokens.peek().type == OPERATOR and self.tokens.peek().value in ('<<', '>>'):\n            op = self.tokens.next().value\n            right = self.parse_add_sub()\n            node = BinaryOpNode(node, op, right)\n        return node\n\n    def parse_add_sub(self):\n        node = self.parse_mul_div()\n        while self.tokens.peek().type == OPERATOR and self.tokens.peek().value in ('+', '-'):\n            op = self.tokens.next().value\n            right = self.parse_mul_div()\n            node = BinaryOpNode(node, op, right)\n        return node\n\n    def parse_mul_div(self):\n        node = self.parse_unary()\n        while self.tokens.peek().type == OPERATOR and self.tokens.peek().value in ('*', '/'):\n            op = self.tokens.next().value\n            right = self.parse_unary()\n            node = BinaryOpNode(node, op, right)\n        return node\n\n    def parse_unary(self):\n        \"\"\"\n        Handles unary operators: '-', '~', and function calls.\n        Multiple consecutive unary minuses are allowed.\n        \"\"\"\n        token = self.tokens.peek()\n        if token.type == OPERATOR and token.value in ('-', '~'):\n            op = self.tokens.next().value\n            operand = self.parse_unary()\n            return UnaryOpNode(op, operand)\n        return self.parse_power()\n\n    def parse_power(self):\n        \"\"\"\n        Handles function calls and parentheses.\n        \"\"\"\n        node = self.parse_primary()\n        # No explicit power operator, but can be added here if needed\n        return node\n\n    def parse_primary(self):\n        token = self.tokens.peek()\n        if token.type == NUMBER:\n            value = self.tokens.next().value\n            return NumberNode(value)\n        elif token.type == IDENTIFIER:\n            name = self.tokens.next().value\n            # Function call or variable\n            if self.tokens.peek().type == LPAREN:\n                self.tokens.next()  # consume '('\n                args = []\n                if self.tokens.peek().type != RPAREN:\n                    while True:\n                        args.append(self.parse_expression())\n                        if self.tokens.peek().type == COMMA:\n                            self.tokens.next()\n                        else:\n                            break\n                self.tokens.expect(RPAREN)\n                return FunctionCallNode(name, args)\n            else:\n                return VariableNode(name)\n        elif token.type == LPAREN:\n            self.tokens.next()\n            node = self.parse_expression()\n            self.tokens.expect(RPAREN)\n            return node\n        else:\n            raise SyntaxError(f\"Unexpected token '{token.value}' at position {token.position}\")\n\n# =============================================================================\n# Evaluator: Walks AST, Computes Results, Manages Variables\n# =============================================================================\n\nclass Evaluator:\n    \"\"\"\n    Evaluates the AST, manages variables, and calls functions.\n    \"\"\"\n    def __init__(self, symbol_table, function_library):\n        self.symbol_table = symbol_table\n        self.function_library = function_library\n\n        # Operator mapping: maps operator symbols to functions\n        self.binary_ops = {\n            '+': operator.add,\n            '-': operator.sub,\n            '*': operator.mul,\n            '/': self._safe_div,\n            '&': operator.and_,\n            '|': operator.or_,\n            '^': operator.xor,\n            '<<': operator.lshift,\n            '>>': operator.rshift,\n        }\n        self.unary_ops = {\n            '-': operator.neg,\n            '~': operator.invert,\n        }\n\n    def _safe_div(self, a, b):\n        if b == 0:\n            raise ZeroDivisionError(\"Division by zero\")\n        return a / b\n\n    def eval(self, node):\n        \"\"\"\n        Recursively evaluates an AST node.\n        \"\"\"\n        if isinstance(node, NumberNode):\n            return node.value\n        elif isinstance(node, VariableNode):\n            return self.symbol_table.get(node.name)\n        elif isinstance(node, UnaryOpNode):\n            operand = self.eval(node.operand)\n            if node.op not in self.unary_ops:\n                raise ValueError(f\"Unsupported unary operator: {node.op}\")\n            return self.unary_ops[node.op](operand)\n        elif isinstance(node, BinaryOpNode):\n            left = self.eval(node.left)\n            right = self.eval(node.right)\n            if node.op not in self.binary_ops:\n                raise ValueError(f\"Unsupported binary operator: {node.op}\")\n            # For bitwise ops, ensure integer operands\n            if node.op in ('&', '|', '^', '<<', '>>', '~'):\n                left = int(left)\n                right = int(right)\n            return self.binary_ops[node.op](left, right)\n        elif isinstance(node, AssignNode):\n            value = self.eval(node.expr)\n            self.symbol_table.set(node.name, value)\n            return value\n        elif isinstance(node, FunctionCallNode):\n            args = [self.eval(arg) for arg in node.args]\n            return self.function_library.call(node.name, args)\n        else:\n            raise TypeError(f\"Unknown AST node type: {type(node)}\")\n\n# =============================================================================\n# REPL Engine: Input Loop, History, Help, and Output\n# =============================================================================\n\nHELP_TEXT = \"\"\"\nScientific Calculator REPL\n--------------------------\nType expressions to evaluate them. Supports:\n\n- Arithmetic: +, -, *, /\n- Bitwise/Logic: &, |, ^, ~, <<, >>\n- Scientific functions: sin(x), cos(x), tan(x), exp(x), log(x), sqrt(x), factorial(x), etc.\n- Variable assignment: x = 5\n- Use variables in expressions: 2 * x + 1\n- Parentheses for grouping: (2 + 3) * 4\n- Multiple unary minuses: --3 == 3\n- Built-in constants: pi, e, tau\n\nCommands:\n  help      Show this help message\n  vars      List defined variables\n  funcs     List available functions\n  exit, quit, Ctrl-D   Exit the calculator\n\nArrow keys: Navigate command history.\n\"\"\"\n\nclass REPL:\n    \"\"\"\n    Read-Eval-Print Loop for the calculator.\n    \"\"\"\n    def __init__(self):\n        self.function_library = FunctionLibrary()\n        self.symbol_table = SymbolTable()\n        self.running = True\n\n        # Setup readline for history and arrow navigation\n        readline.parse_and_bind('tab: complete')\n        readline.set_history_length(100)\n\n    def run(self):\n        \"\"\"\n        Main REPL loop.\n        \"\"\"\n        print(\"Scientific Calculator REPL. Type 'help' for instructions.\")\n        while self.running:\n            try:\n                line = input('>>> ').strip()\n                if not line:\n                    continue\n                if line.lower() in ('exit', 'quit'):\n                    print(\"Goodbye!\")\n                    break\n                elif line.lower() == 'help':\n                    print(HELP_TEXT)\n                    continue\n                elif line.lower() == 'vars':\n                    self._print_vars()\n                    continue\n                elif line.lower() == 'funcs':\n                    self._print_funcs()\n                    continue\n                # Parse and evaluate expression\n                try:\n                    tokenizer = Tokenizer(line)\n                    parser = Parser(tokenizer, self.function_library)\n                    ast = parser.parse()\n                    evaluator = Evaluator(self.symbol_table, self.function_library)\n                    result = evaluator.eval(ast)\n                    print(result)\n                except Exception as e:\n                    print(f\"Error: {e}\")\n            except (EOFError, KeyboardInterrupt):\n                print(\"\\nGoodbye!\")\n                break\n\n    def _print_vars(self):\n        \"\"\"\n        Prints all defined variables and their values.\n        \"\"\"\n        symbols = self.symbol_table.list_symbols()\n        if not symbols:\n            print(\"No variables defined.\")\n        else:\n            for k, v in symbols.items():\n                print(f\"{k} = {v}\")\n\n    def _print_funcs(self):\n        \"\"\"\n        Prints all available functions.\n        \"\"\"\n        funcs = self.function_library.list_functions()\n        print(\"Available functions:\")\n        print(', '.join(funcs))\n\n# =============================================================================\n# Main Entry Point\n# =============================================================================\n\nif __name__ == '__main__':\n    # Start the REPL\n    repl = REPL()\n    repl.run()\n```",
        "```python\n# =============================================================================\n# Command-Line Scientific Calculator (REPL) with Variable Assignment, History,\n# Expression Parsing, Scientific/Logic Functions, and Help Facility\n#\n# Implementation Approach:\n# - Modular design: REPL Engine, Tokenizer, Parser (recursive descent), AST,\n#   Evaluator, Symbol Table, and Function Library.\n# - Uses Python's `readline` for command history and arrow navigation.\n# - Custom tokenizer and parser to handle operator precedence, associativity,\n#   unary minus, and function calls.\n# - Supports variable assignment and usage.\n# - Comprehensive error handling and in-REPL help.\n# - Easily extensible for new functions/operators.\n# =============================================================================\n\nimport math\nimport operator\nimport readline  # For command line history and arrow navigation\nimport sys\nimport re\n\n# =============================================================================\n# Function Library: Scientific and Logic Functions\n# =============================================================================\n\nclass FunctionLibrary:\n    \"\"\"\n    Provides a registry of supported scientific and logic functions.\n    \"\"\"\n    def __init__(self):\n        # Map function names to (callable, arity)\n        self.functions = {\n            'sin':   (math.sin, 1),\n            'cos':   (math.cos, 1),\n            'tan':   (math.tan, 1),\n            'asin':  (math.asin, 1),\n            'acos':  (math.acos, 1),\n            'atan':  (math.atan, 1),\n            'exp':   (math.exp, 1),\n            'log':   (math.log, 1),\n            'log10': (math.log10, 1),\n            'sqrt':  (math.sqrt, 1),\n            'abs':   (abs, 1),\n            'factorial': (math.factorial, 1),\n            'floor': (math.floor, 1),\n            'ceil':  (math.ceil, 1),\n            'round': (round, 1),\n            'deg':   (math.degrees, 1),\n            'rad':   (math.radians, 1),\n            # Logic/bitwise functions\n            'bin':   (bin, 1),\n            'hex':   (hex, 1),\n            'oct':   (oct, 1),\n        }\n\n    def is_function(self, name):\n        \"\"\"\n        Check if a function is registered.\n        \"\"\"\n        return name in self.functions\n\n    def call(self, name, args):\n        \"\"\"\n        Call a registered function with arguments.\n        \"\"\"\n        if name not in self.functions:\n            raise ValueError(f\"Unknown function: {name}\")\n        func, arity = self.functions[name]\n        if len(args) != arity:\n            raise ValueError(f\"Function '{name}' expects {arity} argument(s), got {len(args)}\")\n        try:\n            return func(*args)\n        except Exception as e:\n            raise ValueError(f\"Error in function '{name}': {e}\")\n\n    def list_functions(self):\n        \"\"\"\n        List all registered function names.\n        \"\"\"\n        return sorted(self.functions.keys())\n\n# =============================================================================\n# Symbol Table: Variable Assignment and Lookup\n# =============================================================================\n\nclass SymbolTable:\n    \"\"\"\n    Stores variable assignments and provides lookup.\n    \"\"\"\n    def __init__(self):\n        # Predefine mathematical constants\n        self.symbols = {\n            'pi': math.pi,\n            'e': math.e,\n            'tau': math.tau,\n        }\n\n    def set(self, name, value):\n        \"\"\"\n        Assign a value to a variable.\n        \"\"\"\n        self.symbols[name] = value\n\n    def get(self, name):\n        \"\"\"\n        Retrieve a variable's value.\n        \"\"\"\n        if name not in self.symbols:\n            raise NameError(f\"Undefined variable: '{name}'\")\n        return self.symbols[name]\n\n    def list_symbols(self):\n        \"\"\"\n        List all user-defined and built-in variables.\n        \"\"\"\n        return {k: v for k, v in self.symbols.items() if not k.startswith('_')}\n\n# =============================================================================\n# Tokenizer (Lexer)\n# =============================================================================\n\n# Token types\nNUMBER      = 'NUMBER'\nIDENTIFIER  = 'IDENTIFIER'\nOPERATOR    = 'OPERATOR'\nLPAREN      = 'LPAREN'\nRPAREN      = 'RPAREN'\nCOMMA       = 'COMMA'\nASSIGN      = 'ASSIGN'\nEOF         = 'EOF'\n\n# Token specification (regex patterns)\nTOKEN_SPEC = [\n    (NUMBER,     r'\\d+(\\.\\d*)?([eE][-+]?\\d+)?'),  # Integer or decimal number\n    (IDENTIFIER, r'[A-Za-z_][A-Za-z0-9_]*'),      # Identifiers (variables/functions)\n    (OPERATOR,   r'==|!=|<=|>=|<<|>>|[+\\-*/&|^~<>]'),  # Operators\n    (ASSIGN,     r'='),                           # Assignment\n    (LPAREN,     r'\\('),                          # Left parenthesis\n    (RPAREN,     r'\\)'),                          # Right parenthesis\n    (COMMA,      r','),                           # Comma\n    ('SKIP',     r'[ \\t]+'),                      # Skip spaces/tabs\n    ('MISMATCH', r'.'),                           # Any other character\n]\n\nTOKEN_REGEX = '|'.join(f'(?P<{name}>{pattern})' for name, pattern in TOKEN_SPEC)\n\nclass Token:\n    \"\"\"\n    Represents a single token with type and value.\n    \"\"\"\n    def __init__(self, type_, value, position):\n        self.type = type_\n        self.value = value\n        self.position = position  # Position in input string\n\n    def __repr__(self):\n        return f\"Token({self.type}, {self.value}, pos={self.position})\"\n\nclass Tokenizer:\n    \"\"\"\n    Converts input string into a stream of tokens.\n    \"\"\"\n    def __init__(self, text):\n        self.text = text\n        self.tokens = []\n        self.pos = 0\n        self._tokenize()\n\n    def _tokenize(self):\n        \"\"\"\n        Tokenize the input string into a list of Token objects.\n        \"\"\"\n        for mo in re.finditer(TOKEN_REGEX, self.text):\n            kind = mo.lastgroup\n            value = mo.group()\n            pos = mo.start()\n            if kind == 'NUMBER':\n                value = float(value) if '.' in value or 'e' in value or 'E' in value else int(value)\n                self.tokens.append(Token(NUMBER, value, pos))\n            elif kind == 'IDENTIFIER':\n                self.tokens.append(Token(IDENTIFIER, value, pos))\n            elif kind == 'OPERATOR':\n                self.tokens.append(Token(OPERATOR, value, pos))\n            elif kind == 'ASSIGN':\n                self.tokens.append(Token(ASSIGN, value, pos))\n            elif kind == 'LPAREN':\n                self.tokens.append(Token(LPAREN, value, pos))\n            elif kind == 'RPAREN':\n                self.tokens.append(Token(RPAREN, value, pos))\n            elif kind == 'COMMA':\n                self.tokens.append(Token(COMMA, value, pos))\n            elif kind == 'SKIP':\n                continue\n            elif kind == 'MISMATCH':\n                raise SyntaxError(f\"Unexpected character '{value}' at position {pos}\")\n        self.tokens.append(Token(EOF, None, len(self.text)))\n\n    def peek(self):\n        \"\"\"\n        Peek at the current token without consuming it.\n        \"\"\"\n        return self.tokens[self.pos]\n\n    def next(self):\n        \"\"\"\n        Consume and return the current token.\n        \"\"\"\n        token = self.tokens[self.pos]\n        self.pos += 1\n        return token\n\n    def expect(self, type_, value=None):\n        \"\"\"\n        Expect the next token to match type (and optionally value).\n        \"\"\"\n        token = self.peek()\n        if token.type != type_ or (value is not None and token.value != value):\n            raise SyntaxError(f\"Expected {type_} '{value}' at position {token.position}, got {token.type} '{token.value}'\")\n        return self.next()\n\n# =============================================================================\n# AST Node Definitions\n# =============================================================================\n\nclass ASTNode:\n    \"\"\"\n    Base class for AST nodes.\n    \"\"\"\n    pass\n\nclass NumberNode(ASTNode):\n    \"\"\"\n    AST node for numeric literals.\n    \"\"\"\n    def __init__(self, value):\n        self.value = value\n\nclass VariableNode(ASTNode):\n    \"\"\"\n    AST node for variable references.\n    \"\"\"\n    def __init__(self, name):\n        self.name = name\n\nclass UnaryOpNode(ASTNode):\n    \"\"\"\n    AST node for unary operations.\n    \"\"\"\n    def __init__(self, op, operand):\n        self.op = op\n        self.operand = operand\n\nclass BinaryOpNode(ASTNode):\n    \"\"\"\n    AST node for binary operations.\n    \"\"\"\n    def __init__(self, left, op, right):\n        self.left = left\n        self.op = op\n        self.right = right\n\nclass AssignNode(ASTNode):\n    \"\"\"\n    AST node for variable assignment.\n    \"\"\"\n    def __init__(self, name, expr):\n        self.name = name\n        self.expr = expr\n\nclass FunctionCallNode(ASTNode):\n    \"\"\"\n    AST node for function calls.\n    \"\"\"\n    def __init__(self, name, args):\n        self.name = name\n        self.args = args\n\n# =============================================================================\n# Parser (Recursive Descent)\n# =============================================================================\n\nclass Parser:\n    \"\"\"\n    Builds an AST from tokens, handling precedence and associativity.\n    \"\"\"\n    def __init__(self, tokenizer, function_library):\n        self.tokens = tokenizer\n        self.function_library = function_library\n\n    def parse(self):\n        \"\"\"\n        Entry point: parse an assignment or expression.\n        \"\"\"\n        node = self.parse_assignment()\n        if self.tokens.peek().type != EOF:\n            raise SyntaxError(f\"Unexpected token '{self.tokens.peek().value}' at position {self.tokens.peek().position}\")\n        return node\n\n    def parse_assignment(self):\n        \"\"\"\n        assignment ::= IDENTIFIER '=' expression | expression\n        \"\"\"\n        token = self.tokens.peek()\n        if token.type == IDENTIFIER:\n            # Look ahead for assignment\n            if self.tokens.pos + 1 < len(self.tokens.tokens):\n                next_token = self.tokens.tokens[self.tokens.pos + 1]\n                if next_token.type == ASSIGN:\n                    var_name = self.tokens.next().value\n                    self.tokens.expect(ASSIGN)\n                    expr = self.parse_expression()\n                    return AssignNode(var_name, expr)\n        return self.parse_expression()\n\n    def parse_expression(self):\n        \"\"\"\n        Handles lowest precedence: bitwise OR '|'\n        \"\"\"\n        node = self.parse_bitwise_xor()\n        while self.tokens.peek().type == OPERATOR and self.tokens.peek().value == '|':\n            op = self.tokens.next().value\n            right = self.parse_bitwise_xor()\n            node = BinaryOpNode(node, op, right)\n        return node\n\n    def parse_bitwise_xor(self):\n        node = self.parse_bitwise_and()\n        while self.tokens.peek().type == OPERATOR and self.tokens.peek().value == '^':\n            op = self.tokens.next().value\n            right = self.parse_bitwise_and()\n            node = BinaryOpNode(node, op, right)\n        return node\n\n    def parse_bitwise_and(self):\n        node = self.parse_shift()\n        while self.tokens.peek().type == OPERATOR and self.tokens.peek().value == '&':\n            op = self.tokens.next().value\n            right = self.parse_shift()\n            node = BinaryOpNode(node, op, right)\n        return node\n\n    def parse_shift(self):\n        node = self.parse_add_sub()\n        while self.tokens.peek().type == OPERATOR and self.tokens.peek().value in ('<<', '>>'):\n            op = self.tokens.next().value\n            right = self.parse_add_sub()\n            node = BinaryOpNode(node, op, right)\n        return node\n\n    def parse_add_sub(self):\n        node = self.parse_mul_div()\n        while self.tokens.peek().type == OPERATOR and self.tokens.peek().value in ('+', '-'):\n            op = self.tokens.next().value\n            right = self.parse_mul_div()\n            node = BinaryOpNode(node, op, right)\n        return node\n\n    def parse_mul_div(self):\n        node = self.parse_unary()\n        while self.tokens.peek().type == OPERATOR and self.tokens.peek().value in ('*', '/'):\n            op = self.tokens.next().value\n            right = self.parse_unary()\n            node = BinaryOpNode(node, op, right)\n        return node\n\n    def parse_unary(self):\n        \"\"\"\n        Handles unary operators: '-', '~', and function calls.\n        Multiple consecutive unary minuses are allowed.\n        \"\"\"\n        token = self.tokens.peek()\n        if token.type == OPERATOR and token.value in ('-', '~'):\n            op = self.tokens.next().value\n            operand = self.parse_unary()\n            return UnaryOpNode(op, operand)\n        return self.parse_primary()\n\n    def parse_primary(self):\n        \"\"\"\n        Handles numbers, variables, function calls, and parenthesized expressions.\n        \"\"\"\n        token = self.tokens.peek()\n        if token.type == NUMBER:\n            value = self.tokens.next().value\n            return NumberNode(value)\n        elif token.type == IDENTIFIER:\n            name = self.tokens.next().value\n            # Function call or variable\n            if self.tokens.peek().type == LPAREN:\n                self.tokens.next()  # consume '('\n                args = []\n                if self.tokens.peek().type != RPAREN:\n                    while True:\n                        args.append(self.parse_expression())\n                        if self.tokens.peek().type == COMMA:\n                            self.tokens.next()\n                        else:\n                            break\n                self.tokens.expect(RPAREN)\n                return FunctionCallNode(name, args)\n            else:\n                return VariableNode(name)\n        elif token.type == LPAREN:\n            self.tokens.next()\n            node = self.parse_expression()\n            self.tokens.expect(RPAREN)\n            return node\n        else:\n            raise SyntaxError(f\"Unexpected token '{token.value}' at position {token.position}\")\n\n# =============================================================================\n# Evaluator: Walks AST, Computes Results, Manages Variables\n# =============================================================================\n\nclass Evaluator:\n    \"\"\"\n    Evaluates the AST, manages variables, and calls functions.\n    \"\"\"\n    def __init__(self, symbol_table, function_library):\n        self.symbol_table = symbol_table\n        self.function_library = function_library\n\n        # Operator mapping: maps operator symbols to functions\n        self.binary_ops = {\n            '+': operator.add,\n            '-': operator.sub,\n            '*': operator.mul,\n            '/': self._safe_div,\n            '&': operator.and_,\n            '|': operator.or_,\n            '^': operator.xor,\n            '<<': operator.lshift,\n            '>>': operator.rshift,\n        }\n        self.unary_ops = {\n            '-': operator.neg,\n            '~': operator.invert,\n        }\n\n    def _safe_div(self, a, b):\n        \"\"\"\n        Division with zero check.\n        \"\"\"\n        if b == 0:\n            raise ZeroDivisionError(\"Division by zero\")\n        return a / b\n\n    def eval(self, node):\n        \"\"\"\n        Recursively evaluates an AST node.\n        \"\"\"\n        if isinstance(node, NumberNode):\n            return node.value\n        elif isinstance(node, VariableNode):\n            return self.symbol_table.get(node.name)\n        elif isinstance(node, UnaryOpNode):\n            operand = self.eval(node.operand)\n            if node.op not in self.unary_ops:\n                raise ValueError(f\"Unsupported unary operator: {node.op}\")\n            # Bitwise invert only on integers\n            if node.op == '~':\n                operand = int(operand)\n            return self.unary_ops[node.op](operand)\n        elif isinstance(node, BinaryOpNode):\n            left = self.eval(node.left)\n            right = self.eval(node.right)\n            if node.op not in self.binary_ops:\n                raise ValueError(f\"Unsupported binary operator: {node.op}\")\n            # For bitwise ops, ensure integer operands\n            if node.op in ('&', '|', '^', '<<', '>>'):\n                left = int(left)\n                right = int(right)\n            return self.binary_ops[node.op](left, right)\n        elif isinstance(node, AssignNode):\n            value = self.eval(node.expr)\n            self.symbol_table.set(node.name, value)\n            return value\n        elif isinstance(node, FunctionCallNode):\n            args = [self.eval(arg) for arg in node.args]\n            return self.function_library.call(node.name, args)\n        else:\n            raise TypeError(f\"Unknown AST node type: {type(node)}\")\n\n# =============================================================================\n# REPL Engine: Input Loop, History, Help, and Output\n# =============================================================================\n\nHELP_TEXT = \"\"\"\nScientific Calculator REPL\n--------------------------\nType expressions to evaluate them. Supports:\n\n- Arithmetic: +, -, *, /\n- Bitwise/Logic: &, |, ^, ~, <<, >>\n- Scientific functions: sin(x), cos(x), tan(x), exp(x), log(x), sqrt(x), factorial(x), etc.\n- Variable assignment: x = 5\n- Use variables in expressions: 2 * x + 1\n- Parentheses for grouping: (2 + 3) * 4\n- Multiple unary minuses: --3 == 3\n- Built-in constants: pi, e, tau\n\nCommands:\n  help      Show this help message\n  vars      List defined variables\n  funcs     List available functions\n  exit, quit, Ctrl-D   Exit the calculator\n\nArrow keys: Navigate command history.\n\"\"\"\n\nclass REPL:\n    \"\"\"\n    Read-Eval-Print Loop for the calculator.\n    \"\"\"\n    def __init__(self):\n        self.function_library = FunctionLibrary()\n        self.symbol_table = SymbolTable()\n        self.running = True\n\n        # Setup readline for history and arrow navigation\n        readline.parse_and_bind('tab: complete')\n        readline.set_history_length(100)\n\n    def run(self):\n        \"\"\"\n        Main REPL loop.\n        \"\"\"\n        print(\"Scientific Calculator REPL. Type 'help' for instructions.\")\n        while self.running:\n            try:\n                line = input('>>> ').strip()\n                if not line:\n                    continue\n                if line.lower() in ('exit', 'quit'):\n                    print(\"Goodbye!\")\n                    break\n                elif line.lower() == 'help':\n                    print(HELP_TEXT)\n                    continue\n                elif line.lower() == 'vars':\n                    self._print_vars()\n                    continue\n                elif line.lower() == 'funcs':\n                    self._print_funcs()\n                    continue\n                # Parse and evaluate expression\n                try:\n                    tokenizer = Tokenizer(line)\n                    parser = Parser(tokenizer, self.function_library)\n                    ast = parser.parse()\n                    evaluator = Evaluator(self.symbol_table, self.function_library)\n                    result = evaluator.eval(ast)\n                    print(result)\n                except Exception as e:\n                    print(f\"Error: {e}\")\n            except (EOFError, KeyboardInterrupt):\n                print(\"\\nGoodbye!\")\n                break\n\n    def _print_vars(self):\n        \"\"\"\n        Prints all defined variables and their values.\n        \"\"\"\n        symbols = self.symbol_table.list_symbols()\n        if not symbols:\n            print(\"No variables defined.\")\n        else:\n            for k, v in symbols.items():\n                print(f\"{k} = {v}\")\n\n    def _print_funcs(self):\n        \"\"\"\n        Prints all available functions.\n        \"\"\"\n        funcs = self.function_library.list_functions()\n        print(\"Available functions:\")\n        print(', '.join(funcs))\n\n# =============================================================================\n# Main Entry Point\n# =============================================================================\n\nif __name__ == '__main__':\n    # Start the REPL\n    repl = REPL()\n    repl.run()\n```"
    ],
    "test_reports": [
        {
            "passed": false,
            "results": {
                "compilation_success": true,
                "test_results": [],
                "issues": [],
                "overall_assessment": "Code executed but analysis could not be completed",
                "pass_percentage": 96.36363636363636,
                "passed_count": 53,
                "failed_count": 2,
                "total_count": 55
            }
        },
        {
            "passed": true,
            "results": {
                "compilation_success": true,
                "test_results": [],
                "issues": [],
                "overall_assessment": "Code executed but analysis could not be completed",
                "pass_percentage": 99.35064935064936,
                "passed_count": 153,
                "failed_count": 1,
                "total_count": 154
            }
        }
    ],
    "final_implementation": "```python\n# =============================================================================\n# Command-Line Scientific Calculator (REPL) with Variable Assignment, History,\n# Expression Parsing, Scientific/Logic Functions, and Help Facility\n#\n# Implementation Approach:\n# - Modular design: REPL Engine, Tokenizer, Parser (recursive descent), AST,\n#   Evaluator, Symbol Table, and Function Library.\n# - Uses Python's `readline` for command history and arrow navigation.\n# - Custom tokenizer and parser to handle operator precedence, associativity,\n#   unary minus, and function calls.\n# - Supports variable assignment and usage.\n# - Comprehensive error handling and in-REPL help.\n# - Easily extensible for new functions/operators.\n# =============================================================================\n\nimport math\nimport operator\nimport readline  # For command line history and arrow navigation\nimport sys\nimport re\n\n# =============================================================================\n# Function Library: Scientific and Logic Functions\n# =============================================================================\n\nclass FunctionLibrary:\n    \"\"\"\n    Provides a registry of supported scientific and logic functions.\n    \"\"\"\n    def __init__(self):\n        # Map function names to (callable, arity)\n        self.functions = {\n            'sin':   (math.sin, 1),\n            'cos':   (math.cos, 1),\n            'tan':   (math.tan, 1),\n            'asin':  (math.asin, 1),\n            'acos':  (math.acos, 1),\n            'atan':  (math.atan, 1),\n            'exp':   (math.exp, 1),\n            'log':   (math.log, 1),\n            'log10': (math.log10, 1),\n            'sqrt':  (math.sqrt, 1),\n            'abs':   (abs, 1),\n            'factorial': (math.factorial, 1),\n            'floor': (math.floor, 1),\n            'ceil':  (math.ceil, 1),\n            'round': (round, 1),\n            'deg':   (math.degrees, 1),\n            'rad':   (math.radians, 1),\n            # Logic/bitwise functions\n            'bin':   (bin, 1),\n            'hex':   (hex, 1),\n            'oct':   (oct, 1),\n        }\n\n    def is_function(self, name):\n        \"\"\"\n        Check if a function is registered.\n        \"\"\"\n        return name in self.functions\n\n    def call(self, name, args):\n        \"\"\"\n        Call a registered function with arguments.\n        \"\"\"\n        if name not in self.functions:\n            raise ValueError(f\"Unknown function: {name}\")\n        func, arity = self.functions[name]\n        if len(args) != arity:\n            raise ValueError(f\"Function '{name}' expects {arity} argument(s), got {len(args)}\")\n        try:\n            return func(*args)\n        except Exception as e:\n            raise ValueError(f\"Error in function '{name}': {e}\")\n\n    def list_functions(self):\n        \"\"\"\n        List all registered function names.\n        \"\"\"\n        return sorted(self.functions.keys())\n\n# =============================================================================\n# Symbol Table: Variable Assignment and Lookup\n# =============================================================================\n\nclass SymbolTable:\n    \"\"\"\n    Stores variable assignments and provides lookup.\n    \"\"\"\n    def __init__(self):\n        # Predefine mathematical constants\n        self.symbols = {\n            'pi': math.pi,\n            'e': math.e,\n            'tau': math.tau,\n        }\n\n    def set(self, name, value):\n        \"\"\"\n        Assign a value to a variable.\n        \"\"\"\n        self.symbols[name] = value\n\n    def get(self, name):\n        \"\"\"\n        Retrieve a variable's value.\n        \"\"\"\n        if name not in self.symbols:\n            raise NameError(f\"Undefined variable: '{name}'\")\n        return self.symbols[name]\n\n    def list_symbols(self):\n        \"\"\"\n        List all user-defined and built-in variables.\n        \"\"\"\n        return {k: v for k, v in self.symbols.items() if not k.startswith('_')}\n\n# =============================================================================\n# Tokenizer (Lexer)\n# =============================================================================\n\n# Token types\nNUMBER      = 'NUMBER'\nIDENTIFIER  = 'IDENTIFIER'\nOPERATOR    = 'OPERATOR'\nLPAREN      = 'LPAREN'\nRPAREN      = 'RPAREN'\nCOMMA       = 'COMMA'\nASSIGN      = 'ASSIGN'\nEOF         = 'EOF'\n\n# Token specification (regex patterns)\nTOKEN_SPEC = [\n    (NUMBER,     r'\\d+(\\.\\d*)?([eE][-+]?\\d+)?'),  # Integer or decimal number\n    (IDENTIFIER, r'[A-Za-z_][A-Za-z0-9_]*'),      # Identifiers (variables/functions)\n    (OPERATOR,   r'==|!=|<=|>=|<<|>>|[+\\-*/&|^~<>]'),  # Operators\n    (ASSIGN,     r'='),                           # Assignment\n    (LPAREN,     r'\\('),                          # Left parenthesis\n    (RPAREN,     r'\\)'),                          # Right parenthesis\n    (COMMA,      r','),                           # Comma\n    ('SKIP',     r'[ \\t]+'),                      # Skip spaces/tabs\n    ('MISMATCH', r'.'),                           # Any other character\n]\n\nTOKEN_REGEX = '|'.join(f'(?P<{name}>{pattern})' for name, pattern in TOKEN_SPEC)\n\nclass Token:\n    \"\"\"\n    Represents a single token with type and value.\n    \"\"\"\n    def __init__(self, type_, value, position):\n        self.type = type_\n        self.value = value\n        self.position = position  # Position in input string\n\n    def __repr__(self):\n        return f\"Token({self.type}, {self.value}, pos={self.position})\"\n\nclass Tokenizer:\n    \"\"\"\n    Converts input string into a stream of tokens.\n    \"\"\"\n    def __init__(self, text):\n        self.text = text\n        self.tokens = []\n        self.pos = 0\n        self._tokenize()\n\n    def _tokenize(self):\n        \"\"\"\n        Tokenize the input string into a list of Token objects.\n        \"\"\"\n        for mo in re.finditer(TOKEN_REGEX, self.text):\n            kind = mo.lastgroup\n            value = mo.group()\n            pos = mo.start()\n            if kind == 'NUMBER':\n                value = float(value) if '.' in value or 'e' in value or 'E' in value else int(value)\n                self.tokens.append(Token(NUMBER, value, pos))\n            elif kind == 'IDENTIFIER':\n                self.tokens.append(Token(IDENTIFIER, value, pos))\n            elif kind == 'OPERATOR':\n                self.tokens.append(Token(OPERATOR, value, pos))\n            elif kind == 'ASSIGN':\n                self.tokens.append(Token(ASSIGN, value, pos))\n            elif kind == 'LPAREN':\n                self.tokens.append(Token(LPAREN, value, pos))\n            elif kind == 'RPAREN':\n                self.tokens.append(Token(RPAREN, value, pos))\n            elif kind == 'COMMA':\n                self.tokens.append(Token(COMMA, value, pos))\n            elif kind == 'SKIP':\n                continue\n            elif kind == 'MISMATCH':\n                raise SyntaxError(f\"Unexpected character '{value}' at position {pos}\")\n        self.tokens.append(Token(EOF, None, len(self.text)))\n\n    def peek(self):\n        \"\"\"\n        Peek at the current token without consuming it.\n        \"\"\"\n        return self.tokens[self.pos]\n\n    def next(self):\n        \"\"\"\n        Consume and return the current token.\n        \"\"\"\n        token = self.tokens[self.pos]\n        self.pos += 1\n        return token\n\n    def expect(self, type_, value=None):\n        \"\"\"\n        Expect the next token to match type (and optionally value).\n        \"\"\"\n        token = self.peek()\n        if token.type != type_ or (value is not None and token.value != value):\n            raise SyntaxError(f\"Expected {type_} '{value}' at position {token.position}, got {token.type} '{token.value}'\")\n        return self.next()\n\n# =============================================================================\n# AST Node Definitions\n# =============================================================================\n\nclass ASTNode:\n    \"\"\"\n    Base class for AST nodes.\n    \"\"\"\n    pass\n\nclass NumberNode(ASTNode):\n    \"\"\"\n    AST node for numeric literals.\n    \"\"\"\n    def __init__(self, value):\n        self.value = value\n\nclass VariableNode(ASTNode):\n    \"\"\"\n    AST node for variable references.\n    \"\"\"\n    def __init__(self, name):\n        self.name = name\n\nclass UnaryOpNode(ASTNode):\n    \"\"\"\n    AST node for unary operations.\n    \"\"\"\n    def __init__(self, op, operand):\n        self.op = op\n        self.operand = operand\n\nclass BinaryOpNode(ASTNode):\n    \"\"\"\n    AST node for binary operations.\n    \"\"\"\n    def __init__(self, left, op, right):\n        self.left = left\n        self.op = op\n        self.right = right\n\nclass AssignNode(ASTNode):\n    \"\"\"\n    AST node for variable assignment.\n    \"\"\"\n    def __init__(self, name, expr):\n        self.name = name\n        self.expr = expr\n\nclass FunctionCallNode(ASTNode):\n    \"\"\"\n    AST node for function calls.\n    \"\"\"\n    def __init__(self, name, args):\n        self.name = name\n        self.args = args\n\n# =============================================================================\n# Parser (Recursive Descent)\n# =============================================================================\n\nclass Parser:\n    \"\"\"\n    Builds an AST from tokens, handling precedence and associativity.\n    \"\"\"\n    def __init__(self, tokenizer, function_library):\n        self.tokens = tokenizer\n        self.function_library = function_library\n\n    def parse(self):\n        \"\"\"\n        Entry point: parse an assignment or expression.\n        \"\"\"\n        node = self.parse_assignment()\n        if self.tokens.peek().type != EOF:\n            raise SyntaxError(f\"Unexpected token '{self.tokens.peek().value}' at position {self.tokens.peek().position}\")\n        return node\n\n    def parse_assignment(self):\n        \"\"\"\n        assignment ::= IDENTIFIER '=' expression | expression\n        \"\"\"\n        token = self.tokens.peek()\n        if token.type == IDENTIFIER:\n            # Look ahead for assignment\n            if self.tokens.pos + 1 < len(self.tokens.tokens):\n                next_token = self.tokens.tokens[self.tokens.pos + 1]\n                if next_token.type == ASSIGN:\n                    var_name = self.tokens.next().value\n                    self.tokens.expect(ASSIGN)\n                    expr = self.parse_expression()\n                    return AssignNode(var_name, expr)\n        return self.parse_expression()\n\n    def parse_expression(self):\n        \"\"\"\n        Handles lowest precedence: bitwise OR '|'\n        \"\"\"\n        node = self.parse_bitwise_xor()\n        while self.tokens.peek().type == OPERATOR and self.tokens.peek().value == '|':\n            op = self.tokens.next().value\n            right = self.parse_bitwise_xor()\n            node = BinaryOpNode(node, op, right)\n        return node\n\n    def parse_bitwise_xor(self):\n        node = self.parse_bitwise_and()\n        while self.tokens.peek().type == OPERATOR and self.tokens.peek().value == '^':\n            op = self.tokens.next().value\n            right = self.parse_bitwise_and()\n            node = BinaryOpNode(node, op, right)\n        return node\n\n    def parse_bitwise_and(self):\n        node = self.parse_shift()\n        while self.tokens.peek().type == OPERATOR and self.tokens.peek().value == '&':\n            op = self.tokens.next().value\n            right = self.parse_shift()\n            node = BinaryOpNode(node, op, right)\n        return node\n\n    def parse_shift(self):\n        node = self.parse_add_sub()\n        while self.tokens.peek().type == OPERATOR and self.tokens.peek().value in ('<<', '>>'):\n            op = self.tokens.next().value\n            right = self.parse_add_sub()\n            node = BinaryOpNode(node, op, right)\n        return node\n\n    def parse_add_sub(self):\n        node = self.parse_mul_div()\n        while self.tokens.peek().type == OPERATOR and self.tokens.peek().value in ('+', '-'):\n            op = self.tokens.next().value\n            right = self.parse_mul_div()\n            node = BinaryOpNode(node, op, right)\n        return node\n\n    def parse_mul_div(self):\n        node = self.parse_unary()\n        while self.tokens.peek().type == OPERATOR and self.tokens.peek().value in ('*', '/'):\n            op = self.tokens.next().value\n            right = self.parse_unary()\n            node = BinaryOpNode(node, op, right)\n        return node\n\n    def parse_unary(self):\n        \"\"\"\n        Handles unary operators: '-', '~', and function calls.\n        Multiple consecutive unary minuses are allowed.\n        \"\"\"\n        token = self.tokens.peek()\n        if token.type == OPERATOR and token.value in ('-', '~'):\n            op = self.tokens.next().value\n            operand = self.parse_unary()\n            return UnaryOpNode(op, operand)\n        return self.parse_primary()\n\n    def parse_primary(self):\n        \"\"\"\n        Handles numbers, variables, function calls, and parenthesized expressions.\n        \"\"\"\n        token = self.tokens.peek()\n        if token.type == NUMBER:\n            value = self.tokens.next().value\n            return NumberNode(value)\n        elif token.type == IDENTIFIER:\n            name = self.tokens.next().value\n            # Function call or variable\n            if self.tokens.peek().type == LPAREN:\n                self.tokens.next()  # consume '('\n                args = []\n                if self.tokens.peek().type != RPAREN:\n                    while True:\n                        args.append(self.parse_expression())\n                        if self.tokens.peek().type == COMMA:\n                            self.tokens.next()\n                        else:\n                            break\n                self.tokens.expect(RPAREN)\n                return FunctionCallNode(name, args)\n            else:\n                return VariableNode(name)\n        elif token.type == LPAREN:\n            self.tokens.next()\n            node = self.parse_expression()\n            self.tokens.expect(RPAREN)\n            return node\n        else:\n            raise SyntaxError(f\"Unexpected token '{token.value}' at position {token.position}\")\n\n# =============================================================================\n# Evaluator: Walks AST, Computes Results, Manages Variables\n# =============================================================================\n\nclass Evaluator:\n    \"\"\"\n    Evaluates the AST, manages variables, and calls functions.\n    \"\"\"\n    def __init__(self, symbol_table, function_library):\n        self.symbol_table = symbol_table\n        self.function_library = function_library\n\n        # Operator mapping: maps operator symbols to functions\n        self.binary_ops = {\n            '+': operator.add,\n            '-': operator.sub,\n            '*': operator.mul,\n            '/': self._safe_div,\n            '&': operator.and_,\n            '|': operator.or_,\n            '^': operator.xor,\n            '<<': operator.lshift,\n            '>>': operator.rshift,\n        }\n        self.unary_ops = {\n            '-': operator.neg,\n            '~': operator.invert,\n        }\n\n    def _safe_div(self, a, b):\n        \"\"\"\n        Division with zero check.\n        \"\"\"\n        if b == 0:\n            raise ZeroDivisionError(\"Division by zero\")\n        return a / b\n\n    def eval(self, node):\n        \"\"\"\n        Recursively evaluates an AST node.\n        \"\"\"\n        if isinstance(node, NumberNode):\n            return node.value\n        elif isinstance(node, VariableNode):\n            return self.symbol_table.get(node.name)\n        elif isinstance(node, UnaryOpNode):\n            operand = self.eval(node.operand)\n            if node.op not in self.unary_ops:\n                raise ValueError(f\"Unsupported unary operator: {node.op}\")\n            # Bitwise invert only on integers\n            if node.op == '~':\n                operand = int(operand)\n            return self.unary_ops[node.op](operand)\n        elif isinstance(node, BinaryOpNode):\n            left = self.eval(node.left)\n            right = self.eval(node.right)\n            if node.op not in self.binary_ops:\n                raise ValueError(f\"Unsupported binary operator: {node.op}\")\n            # For bitwise ops, ensure integer operands\n            if node.op in ('&', '|', '^', '<<', '>>'):\n                left = int(left)\n                right = int(right)\n            return self.binary_ops[node.op](left, right)\n        elif isinstance(node, AssignNode):\n            value = self.eval(node.expr)\n            self.symbol_table.set(node.name, value)\n            return value\n        elif isinstance(node, FunctionCallNode):\n            args = [self.eval(arg) for arg in node.args]\n            return self.function_library.call(node.name, args)\n        else:\n            raise TypeError(f\"Unknown AST node type: {type(node)}\")\n\n# =============================================================================\n# REPL Engine: Input Loop, History, Help, and Output\n# =============================================================================\n\nHELP_TEXT = \"\"\"\nScientific Calculator REPL\n--------------------------\nType expressions to evaluate them. Supports:\n\n- Arithmetic: +, -, *, /\n- Bitwise/Logic: &, |, ^, ~, <<, >>\n- Scientific functions: sin(x), cos(x), tan(x), exp(x), log(x), sqrt(x), factorial(x), etc.\n- Variable assignment: x = 5\n- Use variables in expressions: 2 * x + 1\n- Parentheses for grouping: (2 + 3) * 4\n- Multiple unary minuses: --3 == 3\n- Built-in constants: pi, e, tau\n\nCommands:\n  help      Show this help message\n  vars      List defined variables\n  funcs     List available functions\n  exit, quit, Ctrl-D   Exit the calculator\n\nArrow keys: Navigate command history.\n\"\"\"\n\nclass REPL:\n    \"\"\"\n    Read-Eval-Print Loop for the calculator.\n    \"\"\"\n    def __init__(self):\n        self.function_library = FunctionLibrary()\n        self.symbol_table = SymbolTable()\n        self.running = True\n\n        # Setup readline for history and arrow navigation\n        readline.parse_and_bind('tab: complete')\n        readline.set_history_length(100)\n\n    def run(self):\n        \"\"\"\n        Main REPL loop.\n        \"\"\"\n        print(\"Scientific Calculator REPL. Type 'help' for instructions.\")\n        while self.running:\n            try:\n                line = input('>>> ').strip()\n                if not line:\n                    continue\n                if line.lower() in ('exit', 'quit'):\n                    print(\"Goodbye!\")\n                    break\n                elif line.lower() == 'help':\n                    print(HELP_TEXT)\n                    continue\n                elif line.lower() == 'vars':\n                    self._print_vars()\n                    continue\n                elif line.lower() == 'funcs':\n                    self._print_funcs()\n                    continue\n                # Parse and evaluate expression\n                try:\n                    tokenizer = Tokenizer(line)\n                    parser = Parser(tokenizer, self.function_library)\n                    ast = parser.parse()\n                    evaluator = Evaluator(self.symbol_table, self.function_library)\n                    result = evaluator.eval(ast)\n                    print(result)\n                except Exception as e:\n                    print(f\"Error: {e}\")\n            except (EOFError, KeyboardInterrupt):\n                print(\"\\nGoodbye!\")\n                break\n\n    def _print_vars(self):\n        \"\"\"\n        Prints all defined variables and their values.\n        \"\"\"\n        symbols = self.symbol_table.list_symbols()\n        if not symbols:\n            print(\"No variables defined.\")\n        else:\n            for k, v in symbols.items():\n                print(f\"{k} = {v}\")\n\n    def _print_funcs(self):\n        \"\"\"\n        Prints all available functions.\n        \"\"\"\n        funcs = self.function_library.list_functions()\n        print(\"Available functions:\")\n        print(', '.join(funcs))\n\n# =============================================================================\n# Main Entry Point\n# =============================================================================\n\nif __name__ == '__main__':\n    # Start the REPL\n    repl = REPL()\n    repl.run()\n```",
    "final_test_report": {
        "passed": true,
        "results": {
            "compilation_success": true,
            "test_results": [],
            "issues": [],
            "overall_assessment": "Code executed but analysis could not be completed",
            "pass_percentage": 99.35064935064936,
            "passed_count": 153,
            "failed_count": 1,
            "total_count": 154
        }
    },
    "iterations_required": 2,
    "success": true
}