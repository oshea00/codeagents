{
    "architecture_plan": "Problem Analysis\n- You want an interactive command-line calculator (REPL) that supports:\n  - Arithmetic with correct precedence and associativity\n  - Scientific functions (trigonometric, exponential, factorial)\n  - Binary (bitwise) and logical operations\n  - Correct handling of unary operators including repeated unary minus (e.g., --3 == 3)\n  - Variable assignment and usage\n  - Command-line history (up/down arrows)\n  - An in-REPL help facility\n- The most fragile parts are parsing (unary vs binary operators, postfix factorial, precedence and associativity rules) and a safe evaluation strategy (do not simply hand user strings to eval).\n\nRequirements\nFunctional\n1. REPL loop that reads an expression, evaluates it, prints result.\n2. Arithmetic operators: +, -, *, /, % (modulus), ^ or ** for exponentiation.\n3. Unary operators: prefix +, prefix -, bitwise NOT (~), logical NOT (not or !).\n4. Postfix operator: factorial (!).\n5. Binary bitwise operators: &, |, ^ (XOR), <<, >>.\n6. Logical operators: and, or, not, or symbols &&, ||, ! (normalized).\n7. Correct precedence and associativity:\n   - Postfix (factorial) highest\n   - Prefix unary operators next\n   - Exponentiation (right-associative)\n   - Multiplication, division, modulus\n   - Addition, subtraction\n   - Bitwise shifts\n   - Bitwise AND, XOR, OR\n   - Logical AND, OR\n   - Assignment lowest (x = expr)\n   - When precedence equal (and not right-assoc), evaluate left-to-right.\n8. Correct handling of negative number literals via unary operators: do not treat \"-3\" as a single literal token but as unary operator applied to 3; consecutive unary minus alternate sign.\n9. Variable assignment and persistent variable table in REPL session.\n10. Built-in math functions: sin, cos, tan, asin, acos, atan, sqrt, exp, log, pow, abs, floor, ceil, factorial (function form), etc.\n11. Command history via up/down arrows (persisted between sessions).\n12. Help system accessible from REPL (e.g., help, help <topic>, :help).\n13. Error handling with friendly messages (parse error, division by zero, domain error).\n14. Clean exit and optional save/restore of variables.\n\nNon-functional\n- Safe evaluation: no Python eval of raw strings.\n- Reasonable performance for typical expressions.\n- Well-structured code and unit tests.\n\nArchitecture Design\nHigh-level components\n- CLI / REPL front-end\n  - Handles user input, line-editing, history (prompt_toolkit or readline).\n  - Implements special commands (:help, :vars, :exit, :history, :load, :save).\n- Lexer (Tokenizer)\n  - Converts text into tokens: numbers, identifiers, parentheses, operators, commas, assignments.\n  - Does not produce negative-number tokens; '-' is a token always.\n- Parser (Pratt/top-down operator precedence or shunting-yard with unary support)\n  - Builds an AST with correct operator precedence, unary/binary disambiguation, postfix factorial handling, assignment detection.\n  - Operator table defines precedence and associativity.\n- AST nodes and Evaluator\n  - AST node types: Literal, Variable, UnaryOp, BinaryOp, PostfixOp, FuncCall, Assignment.\n  - Evaluator walks AST using symbol table and builtins, doing safe operations, with type checks.\n- Symbol Table / Environment\n  - Map variables to values (numbers, booleans).\n  - Optionally persist to disk.\n- Built-ins & Standard Library\n  - math-based functions, trig, exponential, factorial (both function and postfix operator).\n  - Normalization of logical operators (support both words and symbols).\n- History Manager\n  - Integrates with readline/prompt_toolkit to persist history file.\n- Help System\n  - Static help content and per-topic help for functions/operators; REPL command interface.\n\nOperator precedence and associativity (recommended)\nHigher number = higher precedence\n- 100: Parentheses, function call, variable, literal\n- 90: Postfix: factorial (!) \u2014 left-assoc (applies immediately)\n- 80: Prefix unary: +, -, ~ (bitwise not), not/! (logical not) \u2014 right-assoc (unary binds to following expression)\n- 70: Exponentiation: ^ or ** \u2014 right-assoc\n- 60: *, /, % \u2014 left-assoc\n- 50: +, - (binary) \u2014 left-assoc\n- 40: <<, >> \u2014 left-assoc\n- 30: & \u2014 left-assoc\n- 25: ^ (bitwise XOR) \u2014 left-assoc (pick different token if ^ used for exponent)\n- 20: | \u2014 left-assoc\n- 15: logical and (&& / and) \u2014 left-assoc\n- 10: logical or (|| / or) \u2014 left-assoc\n- 5: assignment (=) \u2014 right-assoc and lowest precedence\n\nNotes:\n- If you choose '^' for exponent, use something else for bitwise XOR (like 'xor' keyword) or reserve '**' for exponent and '^' for bitwise XOR to avoid ambiguity.\n- Postfix factorial must be highest so expressions like -3! parse as unary(-, factorial(3)) which by requirement unary negative should have high precedence \u2014 but factorial being postfix normally binds tighter than prefix unary; choose explicit rule: postfix factorial > prefix unary. That yields -3! == -(3!) which is natural: -3! = -6; whereas --3 still reduces to 3.\n\nExample parsing tokens:\n- --3 -> Unary(-, Unary(-, Literal(3))) -> 3\n- - -3 -> same as above (whitespace ignored)\n- 2^3^2 -> 2^(3^2) due to right associativity\n- 2 * -3 -> Binary(*, Literal(2), Unary(-, Literal(3)))\n\nDevelopment Plan\n(agile sprint-like, with estimated effort in hours for a single experienced developer)\nTotal estimate: 40\u201372 hours depending on polish and test coverage.\n\nPhase 0 \u2014 Setup (2\u20134h)\n- Initialize project skeleton, virtualenv, linting, formatter.\n- Create repo structure:\n  - src/\n    - repl.py\n    - lexer.py\n    - parser.py\n    - ast.py\n    - evaluator.py\n    - builtins.py\n    - history.py\n    - help.py\n  - tests/\n  - README, requirements.txt\n- Set up CI basics (optional).\n\nPhase 1 \u2014 Lexer (4\u20138h)\n- Implement tokenizer supporting:\n  - numbers (ints and floats), identifiers, parentheses, commas\n  - operators: + - * / % ** ^ << >> & | ~ ! = <tokens for && ||>)\n  - token location info for errors\n- Unit tests: tokenization edge cases (consecutive operators, whitespace, decimals).\n\nPhase 2 \u2014 Parser (12\u201318h)\n- Implement Pratt parser (recommended) or shunting-yard with unary and postfix support.\n- Operator table with precedence and associativity as above.\n- Build AST nodes (Literal, Variable, Unary, Binary, Postfix, Call, Assign).\n- Support function calls: f(x,y)\n- Assignment detection: identifier '=' expression -> Assignment node.\n- Unit tests:\n  - Precedence examples, unary chaining (--3), postfix factorial, function calls, assignments.\n\nPhase 3 \u2014 Evaluator & Builtins (8\u201312h)\n- Implement evaluator to traverse AST and compute values safely.\n- Provide built-in functions; map identifiers to functions in builtins module.\n- Implement factorial function and support for postfix '!' operator (validate integer >= 0).\n- Handle math domain errors with clear messages.\n- Implement boolean semantics and binary bitwise semantics; coerce as appropriate (e.g., bitwise on ints only).\n- Unit tests: evaluation correctness, errors, variable usage.\n\nPhase 4 \u2014 REPL, History, Help (6\u201310h)\n- Implement REPL using:\n  - prompt_toolkit (recommended) for robust input, or readline for simpler approach.\n  - History persistence to file (~/.cli_calc_history).\n  - Special commands: :help, help, :vars, :exit, :history.\n  - Implement inline help using help.py content and show function signatures.\n- Unit/integration tests for REPL command handling.\n\nPhase 5 \u2014 Polish, tests, docs (4\u20138h)\n- Add more tests, examples, README documentation, package or installation instructions.\n- Edge cases: chain of factorials, operator spacing, large factorial handling.\n- Optional: config file for radian/degree mode for trig functions.\n\nTechnology Stack\nRecommended primary language: Python 3.10+\nReasons: excellent standard math support, concise parsing/REPL libs, easy packaging, cross-platform.\n\nLibraries\n- prompt_toolkit \u2014 feature-rich line editing, cross-platform arrow keys, async support, history file helper. (Alternative: builtin readline on Unix; Windows needs pyreadline if not using prompt_toolkit.)\n- math \u2014 for math functions (sin, cos, exp, log, sqrt), and math.factorial\n- typing \u2014 dataclasses, type hints\n- pytest \u2014 unit testing\n- optional: mypy for type checking\n\nWhy Pratt parser\n- Pratt parser (top-down operator precedence) cleanly handles prefix, infix, and postfix operators with precedence and associativity rules. It's compact and fits this problem particularly well.\n\nProject file layout (example)\n- src/\n  - cli_calc/\n    - __main__.py\n    - repl.py\n    - lexer.py\n    - parser.py\n    - ast.py\n    - evaluator.py\n    - builtins.py\n    - history.py\n    - help.py\n- tests/\n- README.md\n- requirements.txt\n\nSample operator table to implement in parser (Pythonic pseudocode)\n- tokens: '!' (postfix factorial), 'POS' '+' prefix, 'NEG' '-' prefix, '~' prefix, 'NOT' '!'/ 'not' prefix\n- infix: '**' (right), '*', '/', '%' (left), '+', '-' (left), '<<', '>>' (left),\n  '&', '^', '|' (left), 'and' (left), 'or' (left), '=' assignment (right)\n\nHelp Facility (in-REPL)\n- Commands:\n  - help or :help \u2014 list topics or general help\n  - help <topic> or :help <topic> \u2014 show usage for functions/operators\n  - :vars \u2014 list current variables\n  - :history \u2014 show recent commands or manage history\n  - :exit or Ctrl-D \u2014 exit REPL\n- Provide content for:\n  - arithmetic operators and precedence table\n  - unary vs binary explanation, example (--3)\n  - function list and signatures (sin(x), cos(x), factorial(n) or n!)\n  - variable assignment: x = 3 * sin(1.2)\n\nRisks and Mitigations\n1. Parsing ambiguity (unary vs binary)\n   - Risk: ambiguous cases like \"2*-3\", \"--3\", \"2^ -3\", or interpreting \"-3\" as literal.\n   - Mitigation: Always tokenize '-' as operator and let parser decide prefix vs infix. Write tests for examples and adopt Pratt parser which handles prefix/infix/postfix cleanly.\n\n2. Factorial semantics and domain errors\n   - Risk: factorial on non-integers or large numbers may be undefined or heavy.\n   - Mitigation: Restrict postfix '!' to non-negative integers; if user calls factorial() function, allow float via gamma if you want but warn. Cap or warn on very large factorials (or allow big integers but warn about time/memory).\n\n3. Security (no arbitrary code execution)\n   - Risk: naive use of Python eval exposes environment.\n   - Mitigation: Implement own AST evaluator and do not call eval or exec on user input. Only built-ins that you whitelist are callable.\n\n4. Operator symbol conflicts (e.g., '^' used for both bitwise XOR and exponent)\n   - Mitigation: Choose clear defaults and document them. Recommend '**' for exponent, '^' for bitwise XOR, or allow both but map '^' to exp if user prefers \u2014 but avoid ambiguity: use '**' for exponent.\n\n5. Cross-platform history handling\n   - Risk: builtin readline is limited on Windows.\n   - Mitigation: Use prompt_toolkit which works on Windows and provides history and multiline editing; otherwise fallback to readline + pyreadline on Windows.\n\n6. Error messages and UX\n   - Risk: cryptic parse/eval errors will be annoying.\n   - Mitigation: Provide clear, user-friendly error text including token location. Add helpful examples in help system.\n\n7. Numeric types mixing (int vs float, bitwise ops)\n   - Risk: applying bitwise ops to floats or mixing logical and numeric ops might confuse users.\n   - Mitigation: Perform type checks and coerces explicitly: bitwise must operate on integers (convert if exact integer float?), logical ops return booleans, arithmetic returns floats when any float operand present, etc. Document behavior.\n\nDeliverables for developers\n- Clear entry point: repl.py or __main__.py to start REPL.\n- Lexer/parser/evaluator modules with unit tests per module.\n- Builtins module listing allowed functions and their wrappers.\n- README describing usage, examples, and help command list.\n\nExample usage scenarios to test early\n- --3  -> 3\n- - -3 -> 3\n- 2 * -3 -> -6\n- -3! -> -(3!) == -6\n- (2+3)*4 -> 20\n- 2^3^2 -> 512 if '^' is exponent OR 2^(3^2) with '**' mapping\n- x = 3\n  x * 2 -> 6\n- sin(pi/2) -> 1 (pi provided in builtins)\n- 5 & 3 -> 1 (bitwise AND)\n- 1 && 0 -> 0 (if supporting &&), or True/False if boolean.\n\nIf you want, I can:\n- Provide a concrete Pratt parser implementation in Python (complete code),\n- Or provide a minimal working CLI example using prompt_toolkit that implements the lexer + parser + evaluator. Which would you prefer next?",
    "implementation_history": [
        "```python\n# Implementation of a command-line calculator REPL with lexer, Pratt parser, AST, evaluator, builtins,\n# history, and help system.\n#\n# Design notes:\n# - Uses a hand-written lexer to tokenize input into numbers, identifiers, parentheses, commas, and operators.\n# - Parser implemented as a Pratt (top-down operator precedence) parser supporting prefix, infix, and postfix\n#   operators, including right-associative exponentiation and right-associative assignment.\n# - AST node classes represent expressions: Number, Variable, UnaryOp, BinaryOp, PostfixOp, FuncCall, Assignment.\n# - Evaluator safely computes results using a white-listed set of math functions and explicit handling of\n#   bitwise/logical operations. No use of eval/exec on user input.\n# - REPL with history: tries to use prompt_toolkit; falls back to readline. History persisted to a file\n#   in the user's home directory. Special commands prefixed with ':' or 'help' provide help and utilities.\n#\n# Error handling:\n# - LexerError, ParseError, EvalError for clear user-facing messages and graceful handling in REPL.\n#\n# Usage:\n# - Run this file to start the interactive REPL. Examples:\n#     > x = 3\n#     > y = - -x!\n#     > sin(pi / 2)\n# - Commands:\n#     :help or help -> general help\n#     :help <topic> or help <topic> -> topic help (functions/operators/usage)\n#     :vars -> list variables\n#     :history -> show last 50 history entries\n#     :save <file> -> save variables to JSON\n#     :load <file> -> load variables from JSON\n#     :exit or Ctrl-D -> exit\n#\n# Implementation choices and simplifications:\n# - Exponentiation operator is '**' (right-associative). '^' is bitwise XOR.\n# - Factorial postfix '!' binds tighter than prefix unary, so -3! == -(3!).\n# - Logical operators: 'and', 'or', 'not' and symbols '&&', '||', '!' (prefix logical not) are supported.\n# - Numbers parsed as int when possible; float otherwise.\n# - Bitwise ops require integer-like operands; floats that are integer-valued are coerced to int when safe.\n# - Factorial only allowed on non-negative integers; attempts on negatives or non-integers raise EvalError.\n#\n# NOTE: This is a single-file simplified prototype focusing on correctness of core parsing and evaluation.\n# It is suitable for extension and unit testing.\n\nfrom __future__ import annotations\n\nimport math\nimport os\nimport json\nimport sys\nimport shlex\nfrom dataclasses import dataclass\nfrom typing import Any, Callable, Dict, List, Optional, Tuple, Union\n\n# Try to import prompt_toolkit for a nicer interactive UI; fall back to readline.\ntry:\n    from prompt_toolkit import PromptSession\n    from prompt_toolkit.history import FileHistory\n    from prompt_toolkit.completion import WordCompleter  # optional autocompletion\n    PROMPT_TOOLKIT_AVAILABLE = True\nexcept Exception:\n    PROMPT_TOOLKIT_AVAILABLE = False\n    try:\n        import readline  # type: ignore\n    except Exception:\n        readline = None  # type: ignore\n\n# --------------------------\n# Exceptions\n# --------------------------\n\nclass LexerError(Exception):\n    \"\"\"Raised for errors during tokenization.\"\"\"\n    pass\n\nclass ParseError(Exception):\n    \"\"\"Raised for parsing errors with optional position information.\"\"\"\n    pass\n\nclass EvalError(Exception):\n    \"\"\"Raised for errors during evaluation, e.g., domain errors, type errors.\"\"\"\n    pass\n\n# --------------------------\n# Tokenizer / Lexer\n# --------------------------\n\n@dataclass\nclass Token:\n    \"\"\"Represents a token with type, value, and position.\"\"\"\n    type: str\n    value: Any\n    pos: int\n\n    def __repr__(self) -> str:\n        return f\"Token({self.type}, {self.value}, pos={self.pos})\"\n\n# Token types: NUMBER, IDENT, OP, LPAREN, RPAREN, COMMA, EOF\n_OPERATOR_SYMBOLS = {\n    '<<', '>>', '**', '&&', '||',\n    '+', '-', '*', '/', '%', '^', '&', '|', '~', '!', '=', '<', '>', '(', ')', ',', \n}\n\n# For lexing single-line input, we'll implement a straightforward scanner.\nclass Lexer:\n    \"\"\"Simple lexer for expressions.\n\n    Produces tokens: NUMBER (int or float), IDENT (variables/functions), operators, parentheses, commas.\n    Does not produce negative numbers as single tokens; '-' is always an operator token.\n    \"\"\"\n    def __init__(self, text: str):\n        self.text = text\n        self.pos = 0\n        self.len = len(text)\n\n    def _peek(self, n: int = 0) -> str:\n        i = self.pos + n\n        return self.text[i] if i < self.len else ''\n\n    def _advance(self, n: int = 1) -> None:\n        self.pos += n\n\n    def _match_multichar_op(self) -> Optional[str]:\n        # Try two-character operators first (or three like '>>>', though not used here)\n        if self.pos + 2 <= self.len:\n            two = self.text[self.pos:self.pos + 2]\n            if two in {'<<', '>>', '**', '&&', '||'}:\n                return two\n        # Single char\n        ch = self._peek()\n        if ch in '+-*/%^&|~!=<>() ,':\n            return ch\n        return None\n\n    def _skip_whitespace(self) -> None:\n        while self._peek() and self._peek().isspace():\n            self._advance()\n\n    def _read_number(self) -> Token:\n        start = self.pos\n        has_dot = False\n        has_exp = False\n\n        def is_digit(ch: str) -> bool:\n            return ch.isdigit()\n\n        while True:\n            ch = self._peek()\n            if ch.isdigit():\n                self._advance()\n            elif ch == '.' and not has_dot:\n                has_dot = True\n                self._advance()\n            elif (ch == 'e' or ch == 'E') and not has_exp:\n                # exponent part\n                has_exp = True\n                self._advance()\n                if self._peek() in '+-':\n                    self._advance()\n                # require at least one digit after e/E\n                if not self._peek().isdigit():\n                    raise LexerError(f\"Invalid numeric literal at pos {self.pos}\")\n            else:\n                break\n        raw = self.text[start:self.pos]\n        # Convert to int if possible\n        try:\n            if not has_dot and not has_exp:\n                val = int(raw)\n            else:\n                val = float(raw)\n        except ValueError:\n            raise LexerError(f\"Invalid numeric literal: {raw}\")\n        return Token('NUMBER', val, start)\n\n    def _read_ident(self) -> Token:\n        start = self.pos\n        while True:\n            ch = self._peek()\n            if ch.isalnum() or ch == '_':\n                self._advance()\n            else:\n                break\n        raw = self.text[start:self.pos]\n        return Token('IDENT', raw, start)\n\n    def tokenize(self) -> List[Token]:\n        tokens: List[Token] = []\n        while True:\n            self._skip_whitespace()\n            ch = self._peek()\n            if ch == '':\n                break\n            if ch.isdigit() or (ch == '.' and self._peek(1).isdigit()):\n                tokens.append(self._read_number())\n            elif ch.isalpha() or ch == '_':\n                tok = self._read_ident()\n                # normalize logical keywords\n                if tok.value in {'and', 'or', 'not'}:\n                    tokens.append(Token('OP', tok.value, tok.pos))\n                else:\n                    tokens.append(tok)\n            elif ch in '(),':\n                if ch == '(':\n                    tokens.append(Token('LPAREN', ch, self.pos))\n                elif ch == ')':\n                    tokens.append(Token('RPAREN', ch, self.pos))\n                else:\n                    tokens.append(Token('COMMA', ch, self.pos))\n                self._advance()\n            else:\n                # operator or unknown\n                op = self._match_multichar_op()\n                if op:\n                    # normalize logical symbols to words for parser convenience\n                    if op == '&&':\n                        tokens.append(Token('OP', 'and', self.pos))\n                    elif op == '||':\n                        tokens.append(Token('OP', 'or', self.pos))\n                    else:\n                        tokens.append(Token('OP', op, self.pos))\n                    self._advance(len(op))\n                else:\n                    raise LexerError(f\"Unknown character at pos {self.pos}: {repr(ch)}\")\n        tokens.append(Token('EOF', None, self.pos))\n        return tokens\n\n# --------------------------\n# AST Nodes\n# --------------------------\n\n@dataclass\nclass ASTNode:\n    \"\"\"Base class for AST nodes.\"\"\"\n    pass\n\n@dataclass\nclass Number(ASTNode):\n    value: Union[int, float]\n\n@dataclass\nclass Variable(ASTNode):\n    name: str\n\n@dataclass\nclass UnaryOp(ASTNode):\n    op: str\n    operand: ASTNode\n\n@dataclass\nclass BinaryOp(ASTNode):\n    op: str\n    left: ASTNode\n    right: ASTNode\n\n@dataclass\nclass PostfixOp(ASTNode):\n    op: str  # e.g., '!'\n    operand: ASTNode\n\n@dataclass\nclass FuncCall(ASTNode):\n    name: str\n    args: List[ASTNode]\n\n@dataclass\nclass Assignment(ASTNode):\n    name: str\n    value: ASTNode\n\n# --------------------------\n# Parser (Pratt)\n# --------------------------\n\n# Operator binding powers (bp). Higher value -> higher precedence.\n# Using recommended table, mapping token -> (left_bp, right_bp, associativity)\n# For Pratt, we define left binding power (lbp) used in while loop comparisons and\n# right-binding power (rbp) used when parsing right-hand side for right-assoc operators.\n# For convenience, we'll store a single binding power and use conventions:\n# - For left-assoc infix operators: bp = binding_power, and when parsing led we call parse(rbp=bp)\n# - For right-assoc operators (like exponent, assignment): use rbp = bp - 1 when parsing left?\n# Simpler implementation: store lbp and whether operator is right-assoc.\n_OPERATOR_BP: Dict[str, Tuple[int, bool]] = {\n    # Postfix factorial is handled specially as postfix; we will treat '!' as bp 90 (postfix)\n    '!': (90, False),  # postfix (left assoc conceptually, but it doesn't use rhs)\n    # Prefix unary ops have own handling (bp is the precedence for the operand parsing)\n    'prefix': {\n        '+': 80,\n        '-': 80,\n        '~': 80,\n        'not': 80,\n        '!pre': 80,  # prefix ! (logical not) uses same textual '!' but parser uses context to choose\n    },\n    '**': (70, True),  # exponentiation right-assoc\n    '*': (60, False),\n    '/': (60, False),\n    '%': (60, False),\n    '+': (50, False),\n    '-': (50, False),\n    '<<': (40, False),\n    '>>': (40, False),\n    '&': (30, False),\n    '^': (25, False),  # bitwise XOR (caret) - not exponentiation here\n    '|': (20, False),\n    'and': (15, False),\n    'or': (10, False),\n    '=': (5, True),  # assignment is right-assoc\n}\n\n# The parser uses methods nud (null denotation) for prefix tokens and led (left denotation) for infix/postfix.\n\n\nclass Parser:\n    \"\"\"Pratt parser producing ASTs from token streams.\"\"\"\n\n    def __init__(self, tokens: List[Token]):\n        self.tokens = tokens\n        self.pos = 0\n\n    def _current(self) -> Token:\n        return self.tokens[self.pos]\n\n    def _advance(self) -> Token:\n        tok = self.tokens[self.pos]\n        self.pos += 1\n        return tok\n\n    def _expect(self, typ: str, value: Optional[str] = None) -> Token:\n        tok = self._current()\n        if tok.type != typ or (value is not None and tok.value != value):\n            raise ParseError(f\"Expected {typ} {value} at pos {tok.pos}; got {tok.type} {tok.value}\")\n        return self._advance()\n\n    def parse(self) -> ASTNode:\n        node = self.parse_expression(0)\n        if self._current().type != 'EOF':\n            tok = self._current()\n            raise ParseError(f\"Unexpected token {tok.value!r} at pos {tok.pos}\")\n        return node\n\n    def parse_expression(self, rbp: int = 0) -> ASTNode:\n        tok = self._advance()\n        left = self.nud(tok)\n        # Main loop: while next token has higher binding power than right-binding power, process led\n        while True:\n            cur = self._current()\n            if cur.type == 'OP':\n                bp, _ = _OPERATOR_BP.get(cur.value, (0, False))\n                # postfix '!' should be handled even if it has higher bp; treat specially\n                if cur.value == '!':\n                    # Postfix operator: lbp is 90. Compare to rbp.\n                    if bp <= rbp:\n                        break\n                    # consume postfix\n                    self._advance()\n                    left = PostfixOp('!', left)\n                    continue\n                # other operators: check binding power\n                if bp <= rbp:\n                    break\n                # consume operator\n                op_tok = self._advance()\n                left = self.led(op_tok, left, bp)\n            elif cur.type == 'LPAREN':\n                # function call: highest precedence, binds to previous identifier only or expression result (call on result)\n                # We treat f(x) as FuncCall, but also allow (expr)(args) (call on result) only if left is a variable name\n                if isinstance(left, Variable):\n                    # parse arguments and create FuncCall\n                    args = self._parse_argument_list()\n                    left = FuncCall(left.name, args)\n                    continue\n                else:\n                    # For other cases, parentheses after an expression is a syntax error e.g., (2)(3)\n                    raise ParseError(f\"Unexpected '(' after expression at pos {cur.pos}\")\n            else:\n                break\n        return left\n\n    def nud(self, tok: Token) -> ASTNode:\n        \"\"\"Null denotation: handle tokens that can start expressions.\"\"\"\n        if tok.type == 'NUMBER':\n            return Number(tok.value)\n        if tok.type == 'IDENT':\n            return Variable(tok.value)\n        if tok.type == 'LPAREN':\n            # parenthesized expression\n            expr = self.parse_expression(0)\n            self._expect('RPAREN')\n            return expr\n        if tok.type == 'OP':\n            # prefix operator or maybe a prefix logical not or factorial as prefix? (factorial '!' prefix -> logical not)\n            val = tok.value\n            if val == '!':\n                # prefix '!' = logical not\n                # Use 'not' semantics\n                operand = self.parse_expression(_OPERATOR_BP['prefix']['!pre'])\n                return UnaryOp('not', operand)\n            if val in {'+', '-', '~', 'not'}:\n                bp = _OPERATOR_BP['prefix'][val]\n                operand = self.parse_expression(bp)\n                opname = val\n                return UnaryOp(opname, operand)\n            # For '=' as prefix or other infix only tokens:\n            raise ParseError(f\"Unexpected operator {val!r} at position {tok.pos}\")\n        raise ParseError(f\"Unexpected token {tok.type} {tok.value} at pos {tok.pos}\")\n\n    def led(self, tok: Token, left: ASTNode, lbp: int) -> ASTNode:\n        \"\"\"Left denotation: handle tokens that appear between/after expressions.\"\"\"\n        op = tok.value\n        # Assignment is right-associative and requires left to be a variable\n        if op == '=':\n            if not isinstance(left, Variable):\n                raise ParseError(\"Left-hand side of assignment must be a variable\")\n            # assignment is right-assoc so parse with rbp = binding_power - 1? For Pratt we set rbp = bp - (0 if right-assoc else 1)\n            # We'll parse right-hand side with rbp equal to bp - (1 if right-assoc else 0)\n            bp, right_assoc = _OPERATOR_BP['=']\n            rbp = bp - 1 if right_assoc else bp\n            value = self.parse_expression(rbp)\n            return Assignment(left.name, value)\n\n        # Binary operators\n        if op in _OPERATOR_BP and op != '!':\n            bp, right_assoc = _OPERATOR_BP[op]\n            # For Pratt parser, when operator is left-assoc, parse RHS with rbp = bp\n            # When operator is right-assoc, parse RHS with rbp = bp - 1 (so it binds less)\n            rhs_rbp = bp - 1 if right_assoc else bp\n            right = self.parse_expression(rhs_rbp)\n            return BinaryOp(op, left, right)\n\n        # Parentheses handled in parse_expression loop (function calls). Unexpected op:\n        raise ParseError(f\"Unknown operator {op} at pos {tok.pos}\")\n\n    def _parse_argument_list(self) -> List[ASTNode]:\n        # Assumes current token is LPAREN\n        self._expect('LPAREN')\n        args: List[ASTNode] = []\n        # allow empty args\n        if self._current().type == 'RPAREN':\n            self._advance()\n            return args\n        while True:\n            expr = self.parse_expression(0)\n            args.append(expr)\n            if self._current().type == 'COMMA':\n                self._advance()\n                continue\n            elif self._current().type == 'RPAREN':\n                self._advance()\n                break\n            else:\n                tok = self._current()\n                raise ParseError(f\"Expected ',' or ')' in argument list at pos {tok.pos}\")\n        return args\n\n# --------------------------\n# Builtins / Standard Library\n# --------------------------\n\ndef _safe_float(x: Any) -> float:\n    try:\n        return float(x)\n    except Exception:\n        raise EvalError(f\"Expected numeric value, got {x!r}\")\n\ndef _ensure_int(x: Any) -> int:\n    # Accept int or float that is an exact integer within tolerance\n    if isinstance(x, int):\n        return x\n    if isinstance(x, float):\n        if abs(x - round(x)) < 1e-9:\n            return int(round(x))\n        raise EvalError(f\"Expected integer value, got non-integer {x}\")\n    raise EvalError(f\"Expected integer value, got {type(x).__name__}\")\n\n# Build the allowed function map. Map string name to callable.\n_BUILTINS: Dict[str, Callable] = {}\n\ndef _register(name: str, func: Callable) -> None:\n    _BUILTINS[name] = func\n\n# Register math functions with some safety wrappers\n_register('sin', lambda x: math.sin(_safe_float(x)))\n_register('cos', lambda x: math.cos(_safe_float(x)))\n_register('tan', lambda x: math.tan(_safe_float(x)))\n_register('asin', lambda x: math.asin(_safe_float(x)))\n_register('acos', lambda x: math.acos(_safe_float(x)))\n_register('atan', lambda x: math.atan(_safe_float(x)))\n_register('sqrt', lambda x: math.sqrt(_safe_float(x)))\n_register('exp', lambda x: math.exp(_safe_float(x)))\n_register('log', lambda *args: math.log(*[ _safe_float(a) for a in args ]) )\n_register('pow', lambda x, y: math.pow(_safe_float(x), _safe_float(y)))\n_register('abs', lambda x: abs(_safe_float(x)))\n_register('floor', lambda x: math.floor(_safe_float(x)))\n_register('ceil', lambda x: math.ceil(_safe_float(x)))\n# factorial as function: accept non-negative integers\ndef _builtin_factorial(x):\n    n = _ensure_int(x)\n    if n < 0:\n        raise EvalError(\"factorial() not defined for negative values\")\n    try:\n        return math.factorial(n)\n    except OverflowError:\n        raise EvalError(\"factorial result too large\")\n_register('factorial', _builtin_factorial)\n\n# constants\n_register('pi', lambda: math.pi)\n_register('e', lambda: math.e)\n\n# convenience: boolean helpers\n_register('bool', lambda x: bool(x))\n\n# Provide a list of builtin names for REPL autocompletion/help\n_BUILTIN_NAMES = sorted(_BUILTINS.keys())\n\n# --------------------------\n# Evaluator\n# --------------------------\n\nclass Evaluator:\n    \"\"\"Evaluates AST nodes with a symbol table and builtins.\"\"\"\n\n    def __init__(self):\n        # Environment mapping variable names to values\n        self.env: Dict[str, Any] = {}\n        # Preload constants\n        self.env['pi'] = math.pi\n        self.env['e'] = math.e\n\n    def eval(self, node: ASTNode) -> Any:\n        \"\"\"Dispatch evaluation based on node type.\"\"\"\n        if isinstance(node, Number):\n            return node.value\n        if isinstance(node, Variable):\n            name = node.name\n            if name in self.env:\n                return self.env[name]\n            # Could also be a zero-argument builtin constant like pi/e\n            if name in _BUILTINS and callable(_BUILTINS[name]):\n                try:\n                    return _BUILTINS[name]()\n                except TypeError:\n                    # builtin exists but requires args; fall through to undefined variable\n                    pass\n            raise EvalError(f\"Undefined variable: {name}\")\n        if isinstance(node, UnaryOp):\n            val = self.eval(node.operand)\n            op = node.op\n            if op == '+':\n                return +_safe_float(val)\n            if op == '-':\n                return -_safe_float(val)\n            if op == '~':\n                # bitwise not: convert to int\n                n = _ensure_int(val)\n                return ~n\n            if op == 'not':\n                return not bool(val)\n            raise EvalError(f\"Unknown unary operator: {op}\")\n        if isinstance(node, PostfixOp):\n            op = node.op\n            if op == '!':\n                val = self.eval(node.operand)\n                # factorial: require non-negative integer\n                n = _ensure_int(val)\n                if n < 0:\n                    raise EvalError(\"factorial not defined for negative numbers\")\n                try:\n                    return math.factorial(n)\n                except OverflowError:\n                    raise EvalError(\"factorial result too large\")\n            raise EvalError(f\"Unknown postfix operator: {op}\")\n        if isinstance(node, BinaryOp):\n            left = self.eval(node.left)\n            # short-circuit for logical ops\n            if node.op == 'and':\n                if not bool(left):\n                    return False\n                right = self.eval(node.right)\n                return bool(right)\n            if node.op == 'or':\n                if bool(left):\n                    return True\n                right = self.eval(node.right)\n                return bool(right)\n            # For other ops, evaluate right normally\n            right = self.eval(node.right)\n            op = node.op\n            try:\n                if op == '+':\n                    # preserve ints when both ints\n                    if isinstance(left, int) and isinstance(right, int):\n                        return left + right\n                    return _safe_float(left) + _safe_float(right)\n                if op == '-':\n                    if isinstance(left, int) and isinstance(right, int):\n                        return left - right\n                    return _safe_float(left) - _safe_float(right)\n                if op == '*':\n                    if isinstance(left, int) and isinstance(right, int):\n                        return left * right\n                    return _safe_float(left) * _safe_float(right)\n                if op == '/':\n                    denom = _safe_float(right)\n                    if denom == 0:\n                        raise EvalError(\"Division by zero\")\n                    return _safe_float(left) / denom\n                if op == '%':\n                    # modulus: for ints, int mod; for floats, use float modulo\n                    if isinstance(left, int) and isinstance(right, int):\n                        if right == 0:\n                            raise EvalError(\"Modulo by zero\")\n                        return left % right\n                    denom = _safe_float(right)\n                    if denom == 0:\n                        raise EvalError(\"Modulo by zero\")\n                    return _safe_float(left) % denom\n                if op == '**':\n                    return math.pow(_safe_float(left), _safe_float(right))\n                if op == '^':\n                    # bitwise XOR\n                    l = _ensure_int(left)\n                    r = _ensure_int(right)\n                    return l ^ r\n                if op == '<<':\n                    l = _ensure_int(left)\n                    r = _ensure_int(right)\n                    if r < 0:\n                        raise EvalError(\"negative shift count\")\n                    return l << r\n                if op == '>>':\n                    l = _ensure_int(left)\n                    r = _ensure_int(right)\n                    if r < 0:\n                        raise EvalError(\"negative shift count\")\n                    return l >> r\n                if op == '&':\n                    l = _ensure_int(left)\n                    r = _ensure_int(right)\n                    return l & r\n                if op == '|':\n                    l = _ensure_int(left)\n                    r = _ensure_int(right)\n                    return l | r\n            except EvalError:\n                raise\n            except Exception as e:\n                raise EvalError(f\"Error evaluating binary op {op}: {e}\")\n            raise EvalError(f\"Unknown binary operator: {op}\")\n        if isinstance(node, FuncCall):\n            name = node.name\n            # Lookup in builtins\n            if name in _BUILTINS:\n                func = _BUILTINS[name]\n                args = [self.eval(a) for a in node.args]\n                try:\n                    return func(*args)\n                except TypeError as e:\n                    # Provide clearer message\n                    raise EvalError(f\"Error calling function '{name}': {e}\")\n                except ValueError as e:\n                    raise EvalError(f\"Domain error in function '{name}': {e}\")\n                except Exception as e:\n                    raise EvalError(f\"Error in function '{name}': {e}\")\n            # Allow calling zero-arg variables that are callables? For security, disallow user-defined callables.\n            raise EvalError(f\"Unknown function: {name}\")\n        if isinstance(node, Assignment):\n            val = self.eval(node.value)\n            self.env[node.name] = val\n            return val\n        raise EvalError(f\"Unsupported AST node: {node!r}\")\n\n# --------------------------\n# REPL, History, Help\n# --------------------------\n\nHISTORY_FILE = os.path.expanduser(\"~/.cli_calc_history\")\n\n_HELP_TOPICS = {\n    'general': (\n        \"Calculator REPL help:\\n\"\n        \"Supports arithmetic, bitwise, logical operators, functions, variables, and factorial (!).\\n\"\n        \"Examples:\\n\"\n        \"  x = 3\\n\"\n        \"  2 * -3 -> -6\\n\"\n        \"  -3! -> -(3!) == -6\\n\"\n        \"  --3 -> 3\\n\"\n        \"  sin(pi/2) -> 1\\n\"\n        \"Commands:\\n\"\n        \"  :help, help [topic]    show help\\n\"\n        \"  :vars                  list variables\\n\"\n        \"  :history               show recent history\\n\"\n        \"  :save <file>           save variables to JSON\\n\"\n        \"  :load <file>           load variables from JSON\\n\"\n        \"  :exit                  exit\\n\"\n    ),\n    'operators': (\n        \"Operators and precedence (high -> low):\\n\"\n        \"  postfix: ! (factorial)\\n\"\n        \"  prefix: + - ~ (bitwise not) not/! (logical not)\\n\"\n        \"  exponent: ** (right-assoc)\\n\"\n        \"  * / %\\n\"\n        \"  + -\\n\"\n        \"  << >>\\n\"\n        \"  & ^ |\\n\"\n        \"  and, or\\n\"\n        \"  = (assignment, right-assoc)\\n\"\n        \"Notes:\\n\"\n        \"  - Use '**' for exponentiation (2 ** 3 ** 2 == 2 ** (3 ** 2)).\\n\"\n        \"  - '^' is bitwise XOR.\\n\"\n        \"  - '&&' and '||' are supported as synonyms for 'and' and 'or'.\\n\"\n        \"  - '-' always tokenized as operator; negative literals handled via unary minus (so --3 == 3).\\n\"\n    ),\n    'functions': (\n        \"Built-in functions:\\n\"\n        + \", \".join(_BUILTIN_NAMES) +\n        \"\\nExamples: sin(x), cos(pi), sqrt(2), factorial(5)\\n\"\n    ),\n}\n\ndef show_help(topic: Optional[str] = None) -> str:\n    if not topic:\n        return _HELP_TOPICS['general']\n    key = topic.lower()\n    return _HELP_TOPICS.get(key, f\"No help available for topic '{topic}'\")\n\n# --------------------------\n# REPL Implementation\n# --------------------------\n\nclass REPL:\n    \"\"\"Read-Eval-Print Loop for the calculator.\"\"\"\n\n    def __init__(self):\n        self.evaluator = Evaluator()\n        # try to setup history mechanism\n        self.history_file = HISTORY_FILE\n        if PROMPT_TOOLKIT_AVAILABLE:\n            self.session = PromptSession(history=FileHistory(self.history_file))\n            # simple completer for builtins and variables (dynamically updated when reading)\n            self.completer = WordCompleter(_BUILTIN_NAMES, ignore_case=True)\n        else:\n            # fallback; ensure readline history file is used if readline available\n            if 'readline' in globals() and readline is not None:\n                try:\n                    readline.read_history_file(self.history_file)\n                except Exception:\n                    # ignore if file not exists\n                    pass\n\n    def _save_history(self):\n        if not PROMPT_TOOLKIT_AVAILABLE and 'readline' in globals() and readline is not None:\n            try:\n                readline.write_history_file(self.history_file)\n            except Exception:\n                pass\n\n    def _process_command(self, line: str) -> Optional[str]:\n        \"\"\"Process REPL commands starting with ':' or 'help'.\"\"\"\n        # Strip leading/trailing whitespace\n        s = line.strip()\n        if not s:\n            return None\n        if s.startswith(':'):\n            parts = s[1:].split()\n            cmd = parts[0] if parts else ''\n            args = parts[1:]\n            return self._run_command(cmd, args)\n        if s.startswith('help') or s.startswith('Help'):\n            parts = shlex.split(s)\n            if len(parts) == 1:\n                return show_help(None)\n            else:\n                return show_help(parts[1])\n        return None\n\n    def _run_command(self, cmd: str, args: List[str]) -> Optional[str]:\n        if cmd in {'exit', 'quit'}:\n            raise EOFError()\n        if cmd == 'help':\n            topic = args[0] if args else None\n            return show_help(topic)\n        if cmd == 'vars':\n            lines = []\n            for k, v in sorted(self.evaluator.env.items()):\n                lines.append(f\"{k} = {v!r}\")\n            return \"\\n\".join(lines) if lines else \"(no variables)\"\n        if cmd == 'history':\n            # Show last 50 lines of history file if available\n            try:\n                with open(self.history_file, 'r', encoding='utf-8') as f:\n                    all_lines = f.read().strip().splitlines()\n                last = all_lines[-50:]\n                return \"\\n\".join(last)\n            except Exception as e:\n                return f\"Could not read history: {e}\"\n        if cmd == 'save':\n            if not args:\n                return \"Usage: :save <file>\"\n            fname = args[0]\n            try:\n                with open(fname, 'w', encoding='utf-8') as f:\n                    json.dump(self.evaluator.env, f, default=str)\n                return f\"Saved {len(self.evaluator.env)} variables to {fname}\"\n            except Exception as e:\n                return f\"Error saving variables: {e}\"\n        if cmd == 'load':\n            if not args:\n                return \"Usage: :load <file>\"\n            fname = args[0]\n            try:\n                with open(fname, 'r', encoding='utf-8') as f:\n                    data = json.load(f)\n                if not isinstance(data, dict):\n                    return \"Invalid file format\"\n                for k, v in data.items():\n                    self.evaluator.env[k] = v\n                return f\"Loaded {len(data)} variables from {fname}\"\n            except Exception as e:\n                return f\"Error loading variables: {e}\"\n        return f\"Unknown command: {cmd}\"\n\n    def _normalize_logical_symbols(self, text: str) -> str:\n        # Replace C-style logical operators with words to simplify parsing\n        # But tokenizer already maps && and || to 'and'/'or'. For '!' symbol, tokenizer leaves '!' which can be prefix logical not or postfix factorial.\n        # Also allow '!' used as logical not in prefix position, parser handles it.\n        # Normalize '^' left as bitwise XOR; exponentiation uses '**'.\n        return text\n\n    def evaluate_line(self, line: str) -> Tuple[bool, str]:\n        \"\"\"Parse and evaluate a single line. Returns (ok, message).\"\"\"\n        cmd_out = self._process_command(line)\n        if cmd_out is not None:\n            return True, cmd_out\n        text = self._normalize_logical_symbols(line)\n        try:\n            lexer = Lexer(text)\n            tokens = lexer.tokenize()\n            parser = Parser(tokens)\n            ast = parser.parse()\n            result = self.evaluator.eval(ast)\n            return True, repr(result)\n        except (LexerError, ParseError, EvalError) as e:\n            return False, f\"Error: {e}\"\n        except Exception as e:\n            return False, f\"Unhandled error: {e}\"\n\n    def repl_loop(self) -> None:\n        banner = \"Interactive Calculator REPL. Type :help for help. Ctrl-D or :exit to quit.\"\n        print(banner)\n        try:\n            if PROMPT_TOOLKIT_AVAILABLE:\n                # Provide a completer built from builtins and current vars\n                while True:\n                    try:\n                        # update completer words with current variables\n                        words = list(_BUILTIN_NAMES) + list(self.evaluator.env.keys())\n                        self.completer = WordCompleter(words, ignore_case=True)\n                        line = self.session.prompt('> ', completer=self.completer)\n                    except KeyboardInterrupt:\n                        print(\"^C\")\n                        continue\n                    except EOFError:\n                        print(\"Exiting.\")\n                        break\n                    if not line.strip():\n                        continue\n                    ok, out = self.evaluate_line(line)\n                    if ok:\n                        print(out)\n                    else:\n                        print(out)\n            else:\n                # readline-based simple loop\n                while True:\n                    try:\n                        line = input('> ')\n                    except KeyboardInterrupt:\n                        print(\"^C\")\n                        continue\n                    except EOFError:\n                        print(\"Exiting.\")\n                        break\n                    if not line.strip():\n                        continue\n                    ok, out = self.evaluate_line(line)\n                    if ok:\n                        print(out)\n                    else:\n                        print(out)\n        finally:\n            # save history if needed\n            self._save_history()\n\n# --------------------------\n# Entry point\n# --------------------------\n\ndef main(argv: Optional[List[str]] = None) -> int:\n    repl = REPL()\n    try:\n        repl.repl_loop()\n    except EOFError:\n        pass\n    return 0\n\nif __name__ == '__main__':\n    raise SystemExit(main())\n```",
        "```python\n# Revised implementation of the command-line calculator REPL with lexer, Pratt parser, AST, evaluator, builtins,\n# history, and help system.\n#\n# This revision addresses reported issues:\n# - Unifies factorial semantics between postfix '!' operator and builtin factorial(...) via a single helper.\n# - Hardens REPL command parsing to avoid shlex.split exceptions and unexpected behavior.\n# - Refactors operator precedence tables into explicit prefix/infix/postfix maps to remove ambiguity and ensure\n#   correct precedence & associativity handling for complex expressions.\n# - Improves parser logic for prefix/infix/postfix handling using the clear precedence tables.\n# - Adds robust error messages and safer builtin/function calling.\n#\n# All imports are at the top, and the implementation is self-contained for testing and running.\n# Comments/docstrings explain choices and behaviors. No usage of eval/exec on user input.\n#\n# Note: This is still a prototype focusing on correctness and safety. It is structured for extension\n# and unit testing.\n\nfrom __future__ import annotations\n\nimport math\nimport os\nimport json\nimport sys\nfrom dataclasses import dataclass\nfrom typing import Any, Callable, Dict, List, Optional, Tuple, Union\n\n# Optional UI libs: prompt_toolkit preferred, fallback to readline for history on UNIX.\ntry:\n    from prompt_toolkit import PromptSession\n    from prompt_toolkit.history import FileHistory\n    from prompt_toolkit.completion import WordCompleter\n    PROMPT_TOOLKIT_AVAILABLE = True\nexcept Exception:\n    PROMPT_TOOLKIT_AVAILABLE = False\n    try:\n        import readline  # type: ignore\n    except Exception:\n        readline = None  # type: ignore\n\n# --------------------------\n# Exceptions\n# --------------------------\n\nclass LexerError(Exception):\n    \"\"\"Raised for errors during tokenization.\"\"\"\n    pass\n\nclass ParseError(Exception):\n    \"\"\"Raised for parsing errors with optional position information.\"\"\"\n    pass\n\nclass EvalError(Exception):\n    \"\"\"Raised for errors during evaluation, e.g., domain errors, type errors.\"\"\"\n    pass\n\n# --------------------------\n# Tokenizer / Lexer\n# --------------------------\n\n@dataclass\nclass Token:\n    \"\"\"Represents a token with type, value, and character position.\"\"\"\n    type: str\n    value: Any\n    pos: int\n\n    def __repr__(self) -> str:\n        return f\"Token({self.type}, {self.value!r}, pos={self.pos})\"\n\n# For lexing, define multi-character operator set to recognize before single-char tokens.\n_MULTI_OPS = {'<<', '>>', '**', '&&', '||'}\n_SINGLE_OP_CHARS = set('+-*/%^&|~!=<>() ,')\n\nclass Lexer:\n    \"\"\"Tokenizer for calculator expressions.\n\n    Produces tokens: NUMBER, IDENT, OP, LPAREN, RPAREN, COMMA, EOF.\n    Always tokenizes '-' as operator (no negative literal tokens).\n    \"\"\"\n    def __init__(self, text: str):\n        self.text = text\n        self.pos = 0\n        self.len = len(text)\n\n    def _peek(self, n: int = 0) -> str:\n        i = self.pos + n\n        return self.text[i] if i < self.len else ''\n\n    def _advance(self, n: int = 1) -> None:\n        self.pos += n\n\n    def _skip_whitespace(self) -> None:\n        while self._peek() and self._peek().isspace():\n            self._advance()\n\n    def _read_number(self) -> Token:\n        start = self.pos\n        has_dot = False\n        has_exp = False\n        # integer part and fractional/exponent handling\n        while True:\n            ch = self._peek()\n            if ch.isdigit():\n                self._advance()\n            elif ch == '.' and not has_dot:\n                has_dot = True\n                self._advance()\n            elif (ch == 'e' or ch == 'E') and not has_exp:\n                has_exp = True\n                self._advance()\n                if self._peek() in '+-':\n                    self._advance()\n                # require at least one digit after e/E\n                if not self._peek().isdigit():\n                    raise LexerError(f\"Invalid numeric literal at pos {self.pos}\")\n            else:\n                break\n        raw = self.text[start:self.pos]\n        try:\n            if not has_dot and not has_exp:\n                val: Union[int, float] = int(raw)\n            else:\n                val = float(raw)\n        except ValueError:\n            raise LexerError(f\"Invalid numeric literal: {raw}\")\n        return Token('NUMBER', val, start)\n\n    def _read_ident(self) -> Token:\n        start = self.pos\n        while True:\n            ch = self._peek()\n            if ch.isalnum() or ch == '_':\n                self._advance()\n            else:\n                break\n        raw = self.text[start:self.pos]\n        # normalize 'and', 'or', 'not' into OP tokens for parser convenience\n        if raw in {'and', 'or', 'not'}:\n            return Token('OP', raw, start)\n        return Token('IDENT', raw, start)\n\n    def _match_op(self) -> Optional[str]:\n        # Try multi-char ops first\n        if self.pos + 2 <= self.len:\n            two = self.text[self.pos:self.pos + 2]\n            if two in _MULTI_OPS:\n                return two\n        ch = self._peek()\n        if ch in _SINGLE_OP_CHARS:\n            return ch\n        return None\n\n    def tokenize(self) -> List[Token]:\n        tokens: List[Token] = []\n        while True:\n            self._skip_whitespace()\n            ch = self._peek()\n            if ch == '':\n                break\n            if ch.isdigit() or (ch == '.' and self._peek(1).isdigit()):\n                tokens.append(self._read_number())\n            elif ch.isalpha() or ch == '_':\n                tokens.append(self._read_ident())\n            elif ch in '(),':\n                if ch == '(':\n                    tokens.append(Token('LPAREN', ch, self.pos))\n                elif ch == ')':\n                    tokens.append(Token('RPAREN', ch, self.pos))\n                else:\n                    tokens.append(Token('COMMA', ch, self.pos))\n                self._advance()\n            else:\n                op = self._match_op()\n                if not op:\n                    raise LexerError(f\"Unknown character at pos {self.pos}: {repr(ch)}\")\n                # Normalize C-style logical operators into word forms for parser/evaluator\n                if op == '&&':\n                    tokens.append(Token('OP', 'and', self.pos))\n                elif op == '||':\n                    tokens.append(Token('OP', 'or', self.pos))\n                else:\n                    tokens.append(Token('OP', op, self.pos))\n                self._advance(len(op))\n        tokens.append(Token('EOF', None, self.pos))\n        return tokens\n\n# --------------------------\n# AST Nodes\n# --------------------------\n\n@dataclass\nclass ASTNode:\n    \"\"\"Base AST node.\"\"\"\n    pass\n\n@dataclass\nclass Number(ASTNode):\n    value: Union[int, float]\n\n@dataclass\nclass Variable(ASTNode):\n    name: str\n\n@dataclass\nclass UnaryOp(ASTNode):\n    op: str\n    operand: ASTNode\n\n@dataclass\nclass BinaryOp(ASTNode):\n    op: str\n    left: ASTNode\n    right: ASTNode\n\n@dataclass\nclass PostfixOp(ASTNode):\n    op: str\n    operand: ASTNode\n\n@dataclass\nclass FuncCall(ASTNode):\n    name: str\n    args: List[ASTNode]\n\n@dataclass\nclass Assignment(ASTNode):\n    name: str\n    value: ASTNode\n\n# --------------------------\n# Parser (Pratt/top-down precedence)\n# --------------------------\n\n# Explicit operator precedence maps. Higher number = higher precedence.\n# Postfix operators (apply immediately after primary)\nPOSTFIX_BP: Dict[str, int] = {\n    '!': 90,  # factorial\n}\n\n# Prefix unary operators: bp indicates the precedence used to parse the operand\nPREFIX_BP: Dict[str, int] = {\n    '+': 80,\n    '-': 80,\n    '~': 80,\n    'not': 80,\n    '!': 80,  # treat '!' prefix as logical not\n}\n\n# Infix operators: map to (binding_power, right_assoc)\nINFIX_BP: Dict[str, Tuple[int, bool]] = {\n    '**': (70, True),   # exponentiation (right-assoc)\n    '*': (60, False),\n    '/': (60, False),\n    '%': (60, False),\n    '+': (50, False),\n    '-': (50, False),\n    '<<': (40, False),\n    '>>': (40, False),\n    '&': (30, False),\n    '^': (25, False),   # bitwise XOR\n    '|': (20, False),\n    'and': (15, False),\n    'or': (10, False),\n    '=': (5, True),     # assignment (right-assoc)\n}\n\nclass Parser:\n    \"\"\"Pratt parser producing an AST for expressions.\"\"\"\n\n    def __init__(self, tokens: List[Token]):\n        self.tokens = tokens\n        self.pos = 0\n\n    def _current(self) -> Token:\n        return self.tokens[self.pos]\n\n    def _advance(self) -> Token:\n        tok = self.tokens[self.pos]\n        self.pos += 1\n        return tok\n\n    def _expect(self, typ: str, value: Optional[str] = None) -> Token:\n        tok = self._current()\n        if tok.type != typ or (value is not None and tok.value != value):\n            raise ParseError(f\"Expected {typ} {value} at pos {tok.pos}; got {tok.type} {tok.value}\")\n        return self._advance()\n\n    def parse(self) -> ASTNode:\n        node = self.parse_expression(0)\n        if self._current().type != 'EOF':\n            tok = self._current()\n            raise ParseError(f\"Unexpected token {tok.value!r} at pos {tok.pos}\")\n        return node\n\n    def parse_expression(self, rbp: int = 0) -> ASTNode:\n        # Parse null denotation\n        tok = self._advance()\n        left = self.nud(tok)\n        # While next token has binding power greater than right-binding precedence, consume led/postfix\n        while True:\n            cur = self._current()\n            # Postfix operators have highest precedence, checked first\n            if cur.type == 'OP' and cur.value in POSTFIX_BP and POSTFIX_BP[cur.value] > rbp:\n                # consume postfix operator\n                self._advance()\n                left = PostfixOp(cur.value, left)\n                continue\n            # Function call: LPAREN immediately after a variable is a function call\n            if cur.type == 'LPAREN':\n                # Only treat as function call when left is a variable (identifier)\n                if isinstance(left, Variable):\n                    args = self._parse_argument_list()\n                    left = FuncCall(left.name, args)\n                    continue\n                # else '(' after an expression is a syntax error like (expr)(...)\n                raise ParseError(f\"Unexpected '(' after expression at pos {cur.pos}\")\n            # Infix operators\n            if cur.type == 'OP' and cur.value in INFIX_BP:\n                bp, right_assoc = INFIX_BP[cur.value]\n                if bp <= rbp:\n                    break\n                op_tok = self._advance()\n                # For right-assoc operators, parse right-hand side with rbp = bp - 1\n                rhs_rbp = bp - 1 if right_assoc else bp\n                right = self.parse_expression(rhs_rbp)\n                # Special-case assignment validation: left must be Variable\n                if op_tok.value == '=':\n                    if not isinstance(left, Variable):\n                        raise ParseError(\"Left-hand side of assignment must be a variable\")\n                    left = Assignment(left.name, right)\n                else:\n                    left = BinaryOp(op_tok.value, left, right)\n                continue\n            break\n        return left\n\n    def nud(self, tok: Token) -> ASTNode:\n        \"\"\"Null denotation (prefix/primary).\"\"\"\n        if tok.type == 'NUMBER':\n            return Number(tok.value)\n        if tok.type == 'IDENT':\n            return Variable(tok.value)\n        if tok.type == 'LPAREN':\n            expr = self.parse_expression(0)\n            self._expect('RPAREN')\n            return expr\n        if tok.type == 'OP':\n            val = tok.value\n            # Prefix logical not '!' normalized to prefix not\n            if val == '!':\n                # treat as logical not\n                bp = PREFIX_BP['!']\n                operand = self.parse_expression(bp)\n                return UnaryOp('not', operand)\n            if val in PREFIX_BP:\n                bp = PREFIX_BP[val]\n                operand = self.parse_expression(bp)\n                return UnaryOp(val if val != '!' else 'not', operand)\n            raise ParseError(f\"Unexpected operator {val!r} at pos {tok.pos}\")\n        raise ParseError(f\"Unexpected token {tok.type} {tok.value!r} at pos {tok.pos}\")\n\n    def _parse_argument_list(self) -> List[ASTNode]:\n        \"\"\"Parse '(' expr (, expr)* ')' and return list of AST args. Assumes current token is LPAREN.\"\"\"\n        self._expect('LPAREN')\n        args: List[ASTNode] = []\n        if self._current().type == 'RPAREN':\n            # empty arg list\n            self._advance()\n            return args\n        while True:\n            expr = self.parse_expression(0)\n            args.append(expr)\n            cur = self._current()\n            if cur.type == 'COMMA':\n                self._advance()\n                continue\n            if cur.type == 'RPAREN':\n                self._advance()\n                break\n            raise ParseError(f\"Expected ',' or ')' in argument list at pos {cur.pos}\")\n        return args\n\n# --------------------------\n# Builtins / Standard Library\n# --------------------------\n\ndef _safe_float(x: Any) -> float:\n    try:\n        return float(x)\n    except Exception:\n        raise EvalError(f\"Expected numeric value, got {x!r}\")\n\ndef _ensure_int(x: Any) -> int:\n    \"\"\"Ensure numeric value is integer-like and return int, else raise EvalError.\"\"\"\n    if isinstance(x, int):\n        return x\n    if isinstance(x, float):\n        # Accept floats that represent exact integers (within tolerance)\n        if abs(x - round(x)) < 1e-9:\n            return int(round(x))\n        raise EvalError(f\"Expected integer value, got non-integer {x}\")\n    raise EvalError(f\"Expected integer value, got {type(x).__name__}\")\n\n# Unified factorial helper used both by builtin 'factorial' and postfix '!'\ndef _do_factorial(val: Any) -> int:\n    \"\"\"Compute factorial for non-negative integer-like values and raise EvalError for invalid input.\"\"\"\n    n = _ensure_int(val)\n    if n < 0:\n        raise EvalError(\"factorial not defined for negative numbers\")\n    try:\n        return math.factorial(n)\n    except OverflowError:\n        raise EvalError(\"factorial result too large\")\n\n# Builtins registry: map names to callables.\n_BUILTINS: Dict[str, Callable[..., Any]] = {}\n\ndef _register(name: str, func: Callable[..., Any]) -> None:\n    _BUILTINS[name] = func\n\n# Register math functions with safe wrappers.\n_register('sin', lambda x: math.sin(_safe_float(x)))\n_register('cos', lambda x: math.cos(_safe_float(x)))\n_register('tan', lambda x: math.tan(_safe_float(x)))\n_register('asin', lambda x: math.asin(_safe_float(x)))\n_register('acos', lambda x: math.acos(_safe_float(x)))\n_register('atan', lambda x: math.atan(_safe_float(x)))\n_register('sqrt', lambda x: math.sqrt(_safe_float(x)))\n_register('exp', lambda x: math.exp(_safe_float(x)))\n_register('log', lambda *args: math.log(*[_safe_float(a) for a in args]) )\n_register('pow', lambda x, y: math.pow(_safe_float(x), _safe_float(y)))\n_register('abs', lambda x: abs(_safe_float(x)))\n_register('floor', lambda x: math.floor(_safe_float(x)))\n_register('ceil', lambda x: math.ceil(_safe_float(x)))\n# Register unified factorial function\n_register('factorial', _do_factorial)\n\n# Constants are convenient to have as predefined env entries; we also optionally expose names in builtins list\n# but in evaluation variables are read from the environment first (so 'pi' returns numeric value).\n# We do not register 'pi'/'e' as functions to avoid confusion with pi() call semantics.\n_BUILTIN_EXTRA_NAMES = []  # keep builtins dict for functions only\n\n# Provide builtin names list for help/completion (functions only)\n_BUILTIN_NAMES = sorted(_BUILTINS.keys())\n\n# --------------------------\n# Evaluator\n# --------------------------\n\nclass Evaluator:\n    \"\"\"Evaluates AST nodes with environment and builtins mapping.\"\"\"\n\n    def __init__(self):\n        self.env: Dict[str, Any] = {}\n        # Preload numeric constants into environment\n        self.env['pi'] = math.pi\n        self.env['e'] = math.e\n\n    def eval(self, node: ASTNode) -> Any:\n        \"\"\"Evaluate given AST node and return the result or raise EvalError.\"\"\"\n        if isinstance(node, Number):\n            return node.value\n        if isinstance(node, Variable):\n            name = node.name\n            if name in self.env:\n                return self.env[name]\n            # If name exists as a builtin zero-arg function, don't auto-call it here to avoid confusion.\n            # User can call f() explicitly.\n            raise EvalError(f\"Undefined variable: {name}\")\n        if isinstance(node, UnaryOp):\n            val = self.eval(node.operand)\n            op = node.op\n            if op == '+':\n                return +_safe_float(val)\n            if op == '-':\n                return -_safe_float(val)\n            if op == '~':\n                n = _ensure_int(val)\n                return ~n\n            if op == 'not':\n                return not bool(val)\n            raise EvalError(f\"Unknown unary operator: {op}\")\n        if isinstance(node, PostfixOp):\n            op = node.op\n            if op == '!':\n                val = self.eval(node.operand)\n                return _do_factorial(val)\n            raise EvalError(f\"Unknown postfix operator: {op}\")\n        if isinstance(node, BinaryOp):\n            left_val = self.eval(node.left)\n            # logical short-circuit\n            if node.op == 'and':\n                if not bool(left_val):\n                    return False\n                right_val = self.eval(node.right)\n                return bool(right_val)\n            if node.op == 'or':\n                if bool(left_val):\n                    return True\n                right_val = self.eval(node.right)\n                return bool(right_val)\n            right_val = self.eval(node.right)\n            op = node.op\n            try:\n                if op == '+':\n                    if isinstance(left_val, int) and isinstance(right_val, int):\n                        return left_val + right_val\n                    return _safe_float(left_val) + _safe_float(right_val)\n                if op == '-':\n                    if isinstance(left_val, int) and isinstance(right_val, int):\n                        return left_val - right_val\n                    return _safe_float(left_val) - _safe_float(right_val)\n                if op == '*':\n                    if isinstance(left_val, int) and isinstance(right_val, int):\n                        return left_val * right_val\n                    return _safe_float(left_val) * _safe_float(right_val)\n                if op == '/':\n                    denom = _safe_float(right_val)\n                    if denom == 0:\n                        raise EvalError(\"Division by zero\")\n                    return _safe_float(left_val) / denom\n                if op == '%':\n                    if isinstance(left_val, int) and isinstance(right_val, int):\n                        if right_val == 0:\n                            raise EvalError(\"Modulo by zero\")\n                        return left_val % right_val\n                    denom = _safe_float(right_val)\n                    if denom == 0:\n                        raise EvalError(\"Modulo by zero\")\n                    return _safe_float(left_val) % denom\n                if op == '**':\n                    return math.pow(_safe_float(left_val), _safe_float(right_val))\n                if op == '^':\n                    l = _ensure_int(left_val)\n                    r = _ensure_int(right_val)\n                    return l ^ r\n                if op == '<<':\n                    l = _ensure_int(left_val)\n                    r = _ensure_int(right_val)\n                    if r < 0:\n                        raise EvalError(\"negative shift count\")\n                    return l << r\n                if op == '>>':\n                    l = _ensure_int(left_val)\n                    r = _ensure_int(right_val)\n                    if r < 0:\n                        raise EvalError(\"negative shift count\")\n                    return l >> r\n                if op == '&':\n                    l = _ensure_int(left_val)\n                    r = _ensure_int(right_val)\n                    return l & r\n                if op == '|':\n                    l = _ensure_int(left_val)\n                    r = _ensure_int(right_val)\n                    return l | r\n            except EvalError:\n                raise\n            except Exception as e:\n                raise EvalError(f\"Error evaluating binary op {op}: {e}\")\n            raise EvalError(f\"Unknown binary operator: {op}\")\n        if isinstance(node, FuncCall):\n            name = node.name\n            # Look up function in builtins\n            if name in _BUILTINS:\n                func = _BUILTINS[name]\n                # Evaluate arguments before calling\n                args = [self.eval(a) for a in node.args]\n                try:\n                    return func(*args)\n                except TypeError as e:\n                    raise EvalError(f\"Error calling function '{name}': {e}\")\n                except ValueError as e:\n                    raise EvalError(f\"Domain error in function '{name}': {e}\")\n                except EvalError:\n                    raise\n                except Exception as e:\n                    raise EvalError(f\"Error in function '{name}': {e}\")\n            # If user attempts to call a variable, disallow for safety\n            raise EvalError(f\"Unknown function: {name}\")\n        if isinstance(node, Assignment):\n            val = self.eval(node.value)\n            self.env[node.name] = val\n            return val\n        raise EvalError(f\"Unsupported AST node: {type(node).__name__}\")\n\n# --------------------------\n# REPL, History, Help\n# --------------------------\n\nHISTORY_FILE = os.path.expanduser(\"~/.cli_calc_history\")\n\n_HELP_TOPICS: Dict[str, str] = {\n    'general': (\n        \"Calculator REPL help:\\n\"\n        \"Supports arithmetic, bitwise, logical operators, functions, variables, and factorial (!).\\n\"\n        \"Examples:\\n\"\n        \"  x = 3\\n\"\n        \"  2 * -3 -> -6\\n\"\n        \"  -3! -> -(3!) == -6\\n\"\n        \"  --3 -> 3\\n\"\n        \"  sin(pi/2) -> 1\\n\"\n        \"Commands:\\n\"\n        \"  :help, help [topic]    show help\\n\"\n        \"  :vars                  list variables\\n\"\n        \"  :history               show recent history\\n\"\n        \"  :save <file>           save variables to JSON\\n\"\n        \"  :load <file>           load variables from JSON\\n\"\n        \"  :exit                  exit\\n\"\n    ),\n    'operators': (\n        \"Operators and precedence (high -> low):\\n\"\n        \"  postfix: ! (factorial)\\n\"\n        \"  prefix: + - ~ (bitwise not) not/! (logical not)\\n\"\n        \"  exponent: ** (right-assoc)\\n\"\n        \"  * / %\\n\"\n        \"  + -\\n\"\n        \"  << >>\\n\"\n        \"  & ^ |\\n\"\n        \"  and, or\\n\"\n        \"  = (assignment, right-assoc)\\n\"\n        \"Notes:\\n\"\n        \"  - Use '**' for exponentiation (2 ** 3 ** 2 == 2 ** (3 ** 2)).\\n\"\n        \"  - '^' is bitwise XOR.\\n\"\n        \"  - '&&' and '||' are supported as synonyms for 'and' and 'or'.\\n\"\n        \"  - '-' always tokenized as operator; negative literals handled via unary minus (so --3 == 3).\\n\"\n    ),\n    'functions': (\n        \"Built-in functions:\\n\"\n        + \", \".join(_BUILTIN_NAMES) +\n        \"\\nExamples: sin(x), cos(pi), sqrt(2), factorial(5)\\n\"\n    ),\n}\n\ndef show_help(topic: Optional[str] = None) -> str:\n    \"\"\"Return help text for topic or general if None.\"\"\"\n    if not topic:\n        return _HELP_TOPICS['general']\n    key = topic.lower()\n    return _HELP_TOPICS.get(key, f\"No help available for topic '{topic}'\")\n\nclass REPL:\n    \"\"\"Read-Eval-Print Loop for the calculator.\"\"\"\n\n    def __init__(self):\n        self.evaluator = Evaluator()\n        self.history_file = HISTORY_FILE\n        if PROMPT_TOOLKIT_AVAILABLE:\n            self.session = PromptSession(history=FileHistory(self.history_file))\n            self.completer = WordCompleter(_BUILTIN_NAMES, ignore_case=True)\n        else:\n            if 'readline' in globals() and readline is not None:\n                try:\n                    readline.read_history_file(self.history_file)\n                except Exception:\n                    # ignore missing history\n                    pass\n\n    def _save_history(self) -> None:\n        if not PROMPT_TOOLKIT_AVAILABLE and 'readline' in globals() and readline is not None:\n            try:\n                readline.write_history_file(self.history_file)\n            except Exception:\n                pass\n\n    def _process_command(self, line: str) -> Optional[str]:\n        \"\"\"Process commands starting with ':' or 'help'. Returns response string if a command, else None.\n\n        Hardened to avoid shlex.split exceptions and to use simple, predictable parsing.\n        \"\"\"\n        s = line.strip()\n        if not s:\n            return None\n        # Colon commands like :help, :vars, :save file\n        if s.startswith(':'):\n            body = s[1:].lstrip()\n            if body == '':\n                return \"No command specified. Use :help for available commands.\"\n            # split into command and rest (max 1 split)\n            parts = body.split(None, 1)\n            cmd = parts[0]\n            args_str = parts[1] if len(parts) > 1 else ''\n            args = args_str.split() if args_str else []\n            try:\n                return self._run_command(cmd, args)\n            except EOFError:\n                # bubble EOF to caller to exit\n                raise\n            except Exception as e:\n                # Catch unexpected exceptions from commands and return an error string\n                return f\"Command error: {e}\"\n        # help keyword at line start: allow 'help' or 'help topic'\n        if s.lower().startswith('help'):\n            # split into at most two parts to keep topic intact if it contains spaces\n            parts = s.split(None, 1)\n            if len(parts) == 1:\n                return show_help(None)\n            else:\n                # second part is topic, simple whitespace-trimmed\n                topic = parts[1].strip()\n                return show_help(topic)\n        return None\n\n    def _run_command(self, cmd: str, args: List[str]) -> Optional[str]:\n        \"\"\"Execute a REPL colon command. Raises EOFError for exit/quit to allow outer loop to handle shutdown.\"\"\"\n        cmd_lower = cmd.lower()\n        if cmd_lower in {'exit', 'quit'}:\n            raise EOFError()\n        if cmd_lower == 'help':\n            topic = args[0] if args else None\n            return show_help(topic)\n        if cmd_lower == 'vars':\n            items = sorted(self.evaluator.env.items())\n            if not items:\n                return \"(no variables)\"\n            return \"\\n\".join(f\"{k} = {v!r}\" for k, v in items)\n        if cmd_lower == 'history':\n            try:\n                with open(self.history_file, 'r', encoding='utf-8') as f:\n                    all_lines = f.read().splitlines()\n                last = all_lines[-50:]\n                return \"\\n\".join(last)\n            except Exception as e:\n                return f\"Could not read history: {e}\"\n        if cmd_lower == 'save':\n            if not args:\n                return \"Usage: :save <file>\"\n            fname = args[0]\n            try:\n                with open(fname, 'w', encoding='utf-8') as f:\n                    json.dump(self.evaluator.env, f, default=str)\n                return f\"Saved {len(self.evaluator.env)} variables to {fname}\"\n            except Exception as e:\n                return f\"Error saving variables: {e}\"\n        if cmd_lower == 'load':\n            if not args:\n                return \"Usage: :load <file>\"\n            fname = args[0]\n            try:\n                with open(fname, 'r', encoding='utf-8') as f:\n                    data = json.load(f)\n                if not isinstance(data, dict):\n                    return \"Invalid file format\"\n                for k, v in data.items():\n                    self.evaluator.env[k] = v\n                return f\"Loaded {len(data)} variables from {fname}\"\n            except Exception as e:\n                return f\"Error loading variables: {e}\"\n        return f\"Unknown command: {cmd}\"\n\n    def _normalize_logical_symbols(self, text: str) -> str:\n        \"\"\"Stub for potential normalization; lexer already maps &&/|| to 'and'/'or'.\"\"\"\n        return text\n\n    def evaluate_line(self, line: str) -> Tuple[bool, str]:\n        \"\"\"Evaluate a single line (either command or expression). Returns (ok, output).\"\"\"\n        # First check for commands\n        cmd_out = None\n        try:\n            cmd_out = self._process_command(line)\n        except EOFError:\n            # let callers handle EOF by propagating\n            raise\n        except Exception as e:\n            # Catch any command parsing errors\n            return False, f\"Command processing error: {e}\"\n\n        if cmd_out is not None:\n            return True, cmd_out\n\n        text = self._normalize_logical_symbols(line)\n        try:\n            lexer = Lexer(text)\n            tokens = lexer.tokenize()\n            parser = Parser(tokens)\n            ast = parser.parse()\n            result = self.evaluator.eval(ast)\n            return True, repr(result)\n        except (LexerError, ParseError, EvalError) as e:\n            return False, f\"Error: {e}\"\n        except Exception as e:\n            return False, f\"Unhandled error: {e}\"\n\n    def repl_loop(self) -> None:\n        \"\"\"Interactive REPL loop; integrates with prompt_toolkit if available for history and completion.\"\"\"\n        banner = \"Interactive Calculator REPL. Type :help for help. Ctrl-D or :exit to quit.\"\n        print(banner)\n        try:\n            if PROMPT_TOOLKIT_AVAILABLE:\n                while True:\n                    try:\n                        # update completer with builtins and current variables\n                        words = list(_BUILTIN_NAMES) + list(self.evaluator.env.keys())\n                        self.completer = WordCompleter(words, ignore_case=True)\n                        line = self.session.prompt('> ', completer=self.completer)\n                    except KeyboardInterrupt:\n                        print(\"^C\")\n                        continue\n                    except EOFError:\n                        print(\"Exiting.\")\n                        break\n                    if not line.strip():\n                        continue\n                    ok, out = self.evaluate_line(line)\n                    print(out)\n            else:\n                # readline / input fallback\n                while True:\n                    try:\n                        line = input('> ')\n                    except KeyboardInterrupt:\n                        print(\"^C\")\n                        continue\n                    except EOFError:\n                        print(\"Exiting.\")\n                        break\n                    if not line.strip():\n                        continue\n                    ok, out = self.evaluate_line(line)\n                    print(out)\n        finally:\n            self._save_history()\n\n# --------------------------\n# Entry point\n# --------------------------\n\ndef main(argv: Optional[List[str]] = None) -> int:\n    repl = REPL()\n    try:\n        repl.repl_loop()\n    except EOFError:\n        # graceful exit\n        pass\n    return 0\n\nif __name__ == '__main__':\n    raise SystemExit(main())\n```"
    ],
    "test_reports": [
        {
            "passed": false,
            "results": {
                "compilation_success": true,
                "test_results": [
                    {
                        "test_name": "test_evaluator_postfix_factorial_and_function_factorial",
                        "passed": false,
                        "description": "Verifies that postfix factorial (e.g., 5!) and builtin factorial(5) behave identically and produce appropriate errors for invalid inputs."
                    },
                    {
                        "test_name": "test_repl_evaluate_line_success_and_commands",
                        "passed": false,
                        "description": "Verifies REPL.evaluate_line handles expressions and special commands (help, :vars, :save/:load usage) and returns expected outputs or usage messages."
                    },
                    {
                        "test_name": "test_complex_expression_evaluation",
                        "passed": false,
                        "description": "Verifies parsing and evaluation of a more complex expression exercising precedence/associativity, unary/postfix operators, function calls and bitwise/logical ops."
                    },
                    {
                        "test_name": "other_tests_aggregate",
                        "passed": true,
                        "description": "The remaining 25 tests passed. These cover many lexer, parser, evaluator, REPL path, and builtin function cases."
                    }
                ],
                "issues": [
                    {
                        "type": "logical",
                        "severity": "major",
                        "description": "Inconsistent or unexpected behavior between postfix factorial (!) and builtin factorial(...) (tests failing in test_evaluator_postfix_factorial_and_function_factorial). Possible causes: subtle differences in integer detection or error messages between the postfix evaluator branch and the builtin function, or the parser producing a different AST than expected for expressions involving factorial.",
                        "location": "Evaluator.eval (PostfixOp handling) and builtins registration (_builtin_factorial)",
                        "fix_suggestion": "Unify the logic used by both the postfix '!' operator and the builtin factorial function. For example, factor out the integer-checking and factorial call into a single helper:\n\ndef _factorial_impl(x):\n    n = _ensure_int(x)\n    if n < 0:\n        raise EvalError('factorial not defined for negative numbers')\n    try:\n        return math.factorial(n)\n    except OverflowError:\n        raise EvalError('factorial result too large')\n\nThen in _builtin_factorial do: return _factorial_impl(x)\nAnd in Evaluator.postfix handling do: return _factorial_impl(self.eval(node.operand)).\n\nAlso ensure the same error messages are used (tests may assert message content) so keep messages consistent across both call paths."
                    },
                    {
                        "type": "logical",
                        "severity": "major",
                        "description": "REPL command parsing can raise exceptions or behave unexpectedly for some inputs. The failing REPL test suggests _process_command/_run_command or the 'help' handling may not robustly parse the command string. Using shlex.split() on arbitrary input (including malformed quoting) or indexing parts without checking can raise ValueError/IndexError.",
                        "location": "REPL._process_command and REPL._run_command",
                        "fix_suggestion": "Harden command parsing: avoid shlex.split() for simple command parsing (or catch exceptions). Use safe splitting and guard against empty or malformed input. Example:\n\ns = line.strip()\nif not s:\n    return None\nif s.startswith(':'):\n    body = s[1:].strip()\n    if not body:\n        return 'Unknown command: '\n    parts = body.split(None, 1)\n    cmd = parts[0]\n    args = parts[1].split() if len(parts) > 1 else []\n    return self._run_command(cmd, args)\nif s.lower().startswith('help'):\n    # split at first whitespace to extract topic safely\n    parts = s.split(None, 1)\n    topic = parts[1] if len(parts) > 1 else None\n    return show_help(topic)\n\nAlso wrap shlex.split in try/except and return a friendly usage message instead of letting ValueError propagate."
                    },
                    {
                        "type": "logical",
                        "severity": "major",
                        "description": "Potential operator/precedence mismatch causing complex expression tests to fail. Tests that exercise precedence and associativity (especially around exponentiation '**' vs '^', and interactions between prefix/postfix operators) can reveal parser edge-cases. The current operator table mixes a 'prefix' sub-dictionary inside _OPERATOR_BP which complicates uniform lookups and may lead to inconsistencies in binding power handling.",
                        "location": "Parser.parse_expression / _OPERATOR_BP structure",
                        "fix_suggestion": "Refactor operator precedence tables to be explicit and unambiguous. Use separate mappings for prefix, postfix and infix operators, each mapping operator -> (binding_power, right_assoc). Example:\n\nPREFIX_BP = {'+':80, '-':80, '~':80, 'not':80}\nPOSTFIX_BP = {'!':90}\nINFIX_BP = {'**': (70, True), '*': (60, False), '/': (60, False), '%': (60, False), '+': (50, False), '-': (50, False), '<<': (40, False), '>>': (40, False), '&': (30, False), '^': (25, False), '|': (20, False), 'and': (15, False), 'or': (10, False), '=': (5, True)}\n\nThen use these explicit tables in nud/led/loop comparisons so there is no accidental lookup into a mixed dict. This will also make it straightforward to ensure postfix '!' always binds tighter than prefix.\n\nIf your test-suite expects '^' to be exponentiation (rather than bitwise XOR), decide and either document or provide an alias (map '^' -> '**' in the lexer or parser) \u2014 but be explicit about this choice and reflect it in tests/help text."
                    },
                    {
                        "type": "minor",
                        "severity": "minor",
                        "description": "Use of _OPERATOR_BP mixing different types (the 'prefix' key storing a dict inside a dict that mostly maps operators to tuples) is confusing and fragile. Type annotations do not match runtime structure. This makes reasoning about lookups error-prone.",
                        "location": "Module-level _OPERATOR_BP declaration",
                        "fix_suggestion": "Replace the single _OPERATOR_BP dict with clearly-typed separate dicts as suggested above (PREFIX_BP, POSTFIX_BP, INFIX_BP). This simplifies get calls and reduces surprises."
                    }
                ],
                "test_coverage": "unknown (not measured by test run)",
                "overall_assessment": "The implementation is substantial and mostly correct: it compiles and the majority of unit tests (25/28) passed. Core components (lexer, Pratt parser, AST classes, evaluator, REPL plumbing) work and many builtins behave correctly. The failing tests indicate three important areas to address: unify factorial handling between postfix operator and builtin function, harden REPL command parsing and input handling, and clean up/refactor operator precedence tables to remove any ambiguity (especially around '^' vs '**' and prefix/postfix binding powers). Fixing those will likely make the test-suite pass. Additional suggestions include better separation of prefix/postfix/infix operator tables and consistent error messages so tests can assert on outputs reliably.",
                "pass_percentage": 89.28571428571429,
                "passed_count": 25,
                "failed_count": 3,
                "total_count": 28
            }
        },
        {
            "passed": true,
            "results": {
                "compilation_success": true,
                "test_results": [
                    {
                        "test_name": "test_lexer_tokenization",
                        "passed": true,
                        "description": "Verifies tokenizer correctly produces NUMBER, IDENT, OP, LPAREN, RPAREN, COMMA, EOF tokens for diverse inputs (numbers, identifiers, multi-char ops like '**', '<<', '&&')."
                    },
                    {
                        "test_name": "test_parser_precedence_and_associativity",
                        "passed": true,
                        "description": "Verifies Pratt parser produces ASTs respecting precedence/associativity rules: postfix '!', prefix unary, right-assoc '**' and '=', and left-assoc arithmetic / bitwise operators."
                    },
                    {
                        "test_name": "test_evaluator_basic_arithmetic_and_bitwise",
                        "passed": true,
                        "description": "Checks arithmetic operations (+, -, *, /, %, **) and bitwise ops (&, |, ^, <<, >>) evaluate correctly with proper type handling and error messages on invalid inputs (e.g., division by zero)."
                    },
                    {
                        "test_name": "test_evaluator_postfix_factorial_and_function_factorial",
                        "passed": true,
                        "description": "Ensures postfix '!' and builtin factorial(...) are unified (same semantics) and validate integer/non-negative operands, returning the same results and consistent error messages."
                    },
                    {
                        "test_name": "test_repl_evaluate_line_success_and_commands",
                        "passed": true,
                        "description": "Verifies REPL.evaluate_line handles expression evaluation and REPL commands (:help, help, :vars, :save/:load usage) robustly and returns expected outputs without raising unexpected exceptions."
                    },
                    {
                        "test_name": "test_complex_expression_evaluation",
                        "passed": true,
                        "description": "Integration-style test combining prefix/postfix/unary chains, function calls, bitwise and logical operators to ensure parser + evaluator handle complex inputs correctly."
                    }
                ],
                "issues": [
                    {
                        "type": "suggestion",
                        "severity": "minor",
                        "description": "Constants 'pi' and 'e' are preloaded into the environment but are not included in the builtin function name list used for autocompletion/help. This may confuse users who expect 'pi' listed with function names.",
                        "location": "builtins/env initialization (_BUILTINS, Evaluator.__init__)",
                        "fix_suggestion": "Include constants in the helper name list used for completion/help. For example, define _NAME_COMPLETION = sorted(list(_BUILTINS.keys()) + ['pi','e']) and use that for the completer and the functions help list. Keep 'pi' and 'e' as env values (not callables) but surface them in completions and help."
                    },
                    {
                        "type": "suggestion",
                        "severity": "minor",
                        "description": "Parser disallows constructs like (expr)(args) \u2014 i.e., calling the result of an expression. This is a deliberate design choice for safety, but may surprise advanced users who expect function values or lambdas to be callable. Currently only Variable followed by '(' is treated as a FuncCall.",
                        "location": "Parser.parse_expression (function call handling)",
                        "fix_suggestion": "If you want to support calling any expression result (e.g., higher-order functions), adjust the parser to allow LPAREN after any expression and evaluate callables only if the evaluated left value is callable. Example change: when encountering LPAREN after any left, parse arguments then create a CallOnExpr node; Evaluator would then eval the left and if callable, call it with evaluated args, otherwise raise EvalError. Keep this optional and gated behind an explicit design decision for safety."
                    },
                    {
                        "type": "performance",
                        "severity": "minor",
                        "description": "Using math.pow for exponentiation always produces floats; large integer powers might be better expressed using the Python '**' operator to preserve big-int results when operands are integers.",
                        "location": "Evaluator BinaryOp handling ('**' case)",
                        "fix_suggestion": "If both operands are integer-like and the result is expected to be integer, do integer exponentiation: if left and right evaluate to ints (or exact-int floats), compute left ** right (with _ensure_int for exponent if desired). Otherwise fallback to math.pow or float pow. For example:\nif isinstance(left_val, int) and isinstance(right_val, int):\n    return left_val ** right_val\nelse:\n    return math.pow(_safe_float(left_val), _safe_float(right_val))\nThis preserves integer semantics for integer exponents and avoids float conversion when unnecessary."
                    },
                    {
                        "type": "suggestion",
                        "severity": "minor",
                        "description": "History file defaults to ~/.cli_calc_history. In environments where HOME is not set or is read-only, read/write may fail (caught currently), but tests or users may prefer configurable path.",
                        "location": "HISTORY_FILE constant",
                        "fix_suggestion": "Allow overriding the history file via environment variable or REPL constructor parameter (e.g., CLI_ARG or env var CLI_CALC_HISTORY). Example: HISTORY_FILE = os.environ.get('CLI_CALC_HISTORY', os.path.expanduser('~/.cli_calc_history')). Document fallback behavior in README."
                    },
                    {
                        "type": "security",
                        "severity": "minor",
                        "description": "Builtins are whitelisted and no eval/exec is used \u2014 this is good. However, when saving/loading env via :save/:load, arbitrary objects serialized as strings could be reloaded into the environment with potential type mismatches (not arbitrary code execution, but surprising values).",
                        "location": "REPL._run_command save/load",
                        "fix_suggestion": "When loading a saved JSON, validate each loaded value type (only allow numbers and booleans, maybe strings) before injecting into evaluator.env. For example, if you only support numeric variables, skip non-number entries or raise an informative error. Alternatively, store metadata with types in the saved JSON to enable safer restoration."
                    }
                ],
                "test_coverage": "unknown (not measured by this run)",
                "overall_assessment": "Very good. The revised implementation compiles cleanly and all automated tests passed (100%). The code is well-structured: lexer, parser, AST, evaluator, builtins and REPL are clearly separated. The fixes you implemented (unified factorial, hardened command parsing, explicit prefix/infix/postfix precedence maps) resolved earlier issues and improved robustness. The suggestions above are minor refinements (completion/listing of constants, optional support for calling expressions, integer-preserving exponentiation, configurable history path, and safer load validation) to consider for usability and correctness edge-cases.",
                "pass_percentage": 100.0,
                "passed_count": 30,
                "failed_count": 0,
                "total_count": 30
            }
        }
    ],
    "final_implementation": "```python\n# Revised implementation of the command-line calculator REPL with lexer, Pratt parser, AST, evaluator, builtins,\n# history, and help system.\n#\n# This revision addresses reported issues:\n# - Unifies factorial semantics between postfix '!' operator and builtin factorial(...) via a single helper.\n# - Hardens REPL command parsing to avoid shlex.split exceptions and unexpected behavior.\n# - Refactors operator precedence tables into explicit prefix/infix/postfix maps to remove ambiguity and ensure\n#   correct precedence & associativity handling for complex expressions.\n# - Improves parser logic for prefix/infix/postfix handling using the clear precedence tables.\n# - Adds robust error messages and safer builtin/function calling.\n#\n# All imports are at the top, and the implementation is self-contained for testing and running.\n# Comments/docstrings explain choices and behaviors. No usage of eval/exec on user input.\n#\n# Note: This is still a prototype focusing on correctness and safety. It is structured for extension\n# and unit testing.\n\nfrom __future__ import annotations\n\nimport math\nimport os\nimport json\nimport sys\nfrom dataclasses import dataclass\nfrom typing import Any, Callable, Dict, List, Optional, Tuple, Union\n\n# Optional UI libs: prompt_toolkit preferred, fallback to readline for history on UNIX.\ntry:\n    from prompt_toolkit import PromptSession\n    from prompt_toolkit.history import FileHistory\n    from prompt_toolkit.completion import WordCompleter\n    PROMPT_TOOLKIT_AVAILABLE = True\nexcept Exception:\n    PROMPT_TOOLKIT_AVAILABLE = False\n    try:\n        import readline  # type: ignore\n    except Exception:\n        readline = None  # type: ignore\n\n# --------------------------\n# Exceptions\n# --------------------------\n\nclass LexerError(Exception):\n    \"\"\"Raised for errors during tokenization.\"\"\"\n    pass\n\nclass ParseError(Exception):\n    \"\"\"Raised for parsing errors with optional position information.\"\"\"\n    pass\n\nclass EvalError(Exception):\n    \"\"\"Raised for errors during evaluation, e.g., domain errors, type errors.\"\"\"\n    pass\n\n# --------------------------\n# Tokenizer / Lexer\n# --------------------------\n\n@dataclass\nclass Token:\n    \"\"\"Represents a token with type, value, and character position.\"\"\"\n    type: str\n    value: Any\n    pos: int\n\n    def __repr__(self) -> str:\n        return f\"Token({self.type}, {self.value!r}, pos={self.pos})\"\n\n# For lexing, define multi-character operator set to recognize before single-char tokens.\n_MULTI_OPS = {'<<', '>>', '**', '&&', '||'}\n_SINGLE_OP_CHARS = set('+-*/%^&|~!=<>() ,')\n\nclass Lexer:\n    \"\"\"Tokenizer for calculator expressions.\n\n    Produces tokens: NUMBER, IDENT, OP, LPAREN, RPAREN, COMMA, EOF.\n    Always tokenizes '-' as operator (no negative literal tokens).\n    \"\"\"\n    def __init__(self, text: str):\n        self.text = text\n        self.pos = 0\n        self.len = len(text)\n\n    def _peek(self, n: int = 0) -> str:\n        i = self.pos + n\n        return self.text[i] if i < self.len else ''\n\n    def _advance(self, n: int = 1) -> None:\n        self.pos += n\n\n    def _skip_whitespace(self) -> None:\n        while self._peek() and self._peek().isspace():\n            self._advance()\n\n    def _read_number(self) -> Token:\n        start = self.pos\n        has_dot = False\n        has_exp = False\n        # integer part and fractional/exponent handling\n        while True:\n            ch = self._peek()\n            if ch.isdigit():\n                self._advance()\n            elif ch == '.' and not has_dot:\n                has_dot = True\n                self._advance()\n            elif (ch == 'e' or ch == 'E') and not has_exp:\n                has_exp = True\n                self._advance()\n                if self._peek() in '+-':\n                    self._advance()\n                # require at least one digit after e/E\n                if not self._peek().isdigit():\n                    raise LexerError(f\"Invalid numeric literal at pos {self.pos}\")\n            else:\n                break\n        raw = self.text[start:self.pos]\n        try:\n            if not has_dot and not has_exp:\n                val: Union[int, float] = int(raw)\n            else:\n                val = float(raw)\n        except ValueError:\n            raise LexerError(f\"Invalid numeric literal: {raw}\")\n        return Token('NUMBER', val, start)\n\n    def _read_ident(self) -> Token:\n        start = self.pos\n        while True:\n            ch = self._peek()\n            if ch.isalnum() or ch == '_':\n                self._advance()\n            else:\n                break\n        raw = self.text[start:self.pos]\n        # normalize 'and', 'or', 'not' into OP tokens for parser convenience\n        if raw in {'and', 'or', 'not'}:\n            return Token('OP', raw, start)\n        return Token('IDENT', raw, start)\n\n    def _match_op(self) -> Optional[str]:\n        # Try multi-char ops first\n        if self.pos + 2 <= self.len:\n            two = self.text[self.pos:self.pos + 2]\n            if two in _MULTI_OPS:\n                return two\n        ch = self._peek()\n        if ch in _SINGLE_OP_CHARS:\n            return ch\n        return None\n\n    def tokenize(self) -> List[Token]:\n        tokens: List[Token] = []\n        while True:\n            self._skip_whitespace()\n            ch = self._peek()\n            if ch == '':\n                break\n            if ch.isdigit() or (ch == '.' and self._peek(1).isdigit()):\n                tokens.append(self._read_number())\n            elif ch.isalpha() or ch == '_':\n                tokens.append(self._read_ident())\n            elif ch in '(),':\n                if ch == '(':\n                    tokens.append(Token('LPAREN', ch, self.pos))\n                elif ch == ')':\n                    tokens.append(Token('RPAREN', ch, self.pos))\n                else:\n                    tokens.append(Token('COMMA', ch, self.pos))\n                self._advance()\n            else:\n                op = self._match_op()\n                if not op:\n                    raise LexerError(f\"Unknown character at pos {self.pos}: {repr(ch)}\")\n                # Normalize C-style logical operators into word forms for parser/evaluator\n                if op == '&&':\n                    tokens.append(Token('OP', 'and', self.pos))\n                elif op == '||':\n                    tokens.append(Token('OP', 'or', self.pos))\n                else:\n                    tokens.append(Token('OP', op, self.pos))\n                self._advance(len(op))\n        tokens.append(Token('EOF', None, self.pos))\n        return tokens\n\n# --------------------------\n# AST Nodes\n# --------------------------\n\n@dataclass\nclass ASTNode:\n    \"\"\"Base AST node.\"\"\"\n    pass\n\n@dataclass\nclass Number(ASTNode):\n    value: Union[int, float]\n\n@dataclass\nclass Variable(ASTNode):\n    name: str\n\n@dataclass\nclass UnaryOp(ASTNode):\n    op: str\n    operand: ASTNode\n\n@dataclass\nclass BinaryOp(ASTNode):\n    op: str\n    left: ASTNode\n    right: ASTNode\n\n@dataclass\nclass PostfixOp(ASTNode):\n    op: str\n    operand: ASTNode\n\n@dataclass\nclass FuncCall(ASTNode):\n    name: str\n    args: List[ASTNode]\n\n@dataclass\nclass Assignment(ASTNode):\n    name: str\n    value: ASTNode\n\n# --------------------------\n# Parser (Pratt/top-down precedence)\n# --------------------------\n\n# Explicit operator precedence maps. Higher number = higher precedence.\n# Postfix operators (apply immediately after primary)\nPOSTFIX_BP: Dict[str, int] = {\n    '!': 90,  # factorial\n}\n\n# Prefix unary operators: bp indicates the precedence used to parse the operand\nPREFIX_BP: Dict[str, int] = {\n    '+': 80,\n    '-': 80,\n    '~': 80,\n    'not': 80,\n    '!': 80,  # treat '!' prefix as logical not\n}\n\n# Infix operators: map to (binding_power, right_assoc)\nINFIX_BP: Dict[str, Tuple[int, bool]] = {\n    '**': (70, True),   # exponentiation (right-assoc)\n    '*': (60, False),\n    '/': (60, False),\n    '%': (60, False),\n    '+': (50, False),\n    '-': (50, False),\n    '<<': (40, False),\n    '>>': (40, False),\n    '&': (30, False),\n    '^': (25, False),   # bitwise XOR\n    '|': (20, False),\n    'and': (15, False),\n    'or': (10, False),\n    '=': (5, True),     # assignment (right-assoc)\n}\n\nclass Parser:\n    \"\"\"Pratt parser producing an AST for expressions.\"\"\"\n\n    def __init__(self, tokens: List[Token]):\n        self.tokens = tokens\n        self.pos = 0\n\n    def _current(self) -> Token:\n        return self.tokens[self.pos]\n\n    def _advance(self) -> Token:\n        tok = self.tokens[self.pos]\n        self.pos += 1\n        return tok\n\n    def _expect(self, typ: str, value: Optional[str] = None) -> Token:\n        tok = self._current()\n        if tok.type != typ or (value is not None and tok.value != value):\n            raise ParseError(f\"Expected {typ} {value} at pos {tok.pos}; got {tok.type} {tok.value}\")\n        return self._advance()\n\n    def parse(self) -> ASTNode:\n        node = self.parse_expression(0)\n        if self._current().type != 'EOF':\n            tok = self._current()\n            raise ParseError(f\"Unexpected token {tok.value!r} at pos {tok.pos}\")\n        return node\n\n    def parse_expression(self, rbp: int = 0) -> ASTNode:\n        # Parse null denotation\n        tok = self._advance()\n        left = self.nud(tok)\n        # While next token has binding power greater than right-binding precedence, consume led/postfix\n        while True:\n            cur = self._current()\n            # Postfix operators have highest precedence, checked first\n            if cur.type == 'OP' and cur.value in POSTFIX_BP and POSTFIX_BP[cur.value] > rbp:\n                # consume postfix operator\n                self._advance()\n                left = PostfixOp(cur.value, left)\n                continue\n            # Function call: LPAREN immediately after a variable is a function call\n            if cur.type == 'LPAREN':\n                # Only treat as function call when left is a variable (identifier)\n                if isinstance(left, Variable):\n                    args = self._parse_argument_list()\n                    left = FuncCall(left.name, args)\n                    continue\n                # else '(' after an expression is a syntax error like (expr)(...)\n                raise ParseError(f\"Unexpected '(' after expression at pos {cur.pos}\")\n            # Infix operators\n            if cur.type == 'OP' and cur.value in INFIX_BP:\n                bp, right_assoc = INFIX_BP[cur.value]\n                if bp <= rbp:\n                    break\n                op_tok = self._advance()\n                # For right-assoc operators, parse right-hand side with rbp = bp - 1\n                rhs_rbp = bp - 1 if right_assoc else bp\n                right = self.parse_expression(rhs_rbp)\n                # Special-case assignment validation: left must be Variable\n                if op_tok.value == '=':\n                    if not isinstance(left, Variable):\n                        raise ParseError(\"Left-hand side of assignment must be a variable\")\n                    left = Assignment(left.name, right)\n                else:\n                    left = BinaryOp(op_tok.value, left, right)\n                continue\n            break\n        return left\n\n    def nud(self, tok: Token) -> ASTNode:\n        \"\"\"Null denotation (prefix/primary).\"\"\"\n        if tok.type == 'NUMBER':\n            return Number(tok.value)\n        if tok.type == 'IDENT':\n            return Variable(tok.value)\n        if tok.type == 'LPAREN':\n            expr = self.parse_expression(0)\n            self._expect('RPAREN')\n            return expr\n        if tok.type == 'OP':\n            val = tok.value\n            # Prefix logical not '!' normalized to prefix not\n            if val == '!':\n                # treat as logical not\n                bp = PREFIX_BP['!']\n                operand = self.parse_expression(bp)\n                return UnaryOp('not', operand)\n            if val in PREFIX_BP:\n                bp = PREFIX_BP[val]\n                operand = self.parse_expression(bp)\n                return UnaryOp(val if val != '!' else 'not', operand)\n            raise ParseError(f\"Unexpected operator {val!r} at pos {tok.pos}\")\n        raise ParseError(f\"Unexpected token {tok.type} {tok.value!r} at pos {tok.pos}\")\n\n    def _parse_argument_list(self) -> List[ASTNode]:\n        \"\"\"Parse '(' expr (, expr)* ')' and return list of AST args. Assumes current token is LPAREN.\"\"\"\n        self._expect('LPAREN')\n        args: List[ASTNode] = []\n        if self._current().type == 'RPAREN':\n            # empty arg list\n            self._advance()\n            return args\n        while True:\n            expr = self.parse_expression(0)\n            args.append(expr)\n            cur = self._current()\n            if cur.type == 'COMMA':\n                self._advance()\n                continue\n            if cur.type == 'RPAREN':\n                self._advance()\n                break\n            raise ParseError(f\"Expected ',' or ')' in argument list at pos {cur.pos}\")\n        return args\n\n# --------------------------\n# Builtins / Standard Library\n# --------------------------\n\ndef _safe_float(x: Any) -> float:\n    try:\n        return float(x)\n    except Exception:\n        raise EvalError(f\"Expected numeric value, got {x!r}\")\n\ndef _ensure_int(x: Any) -> int:\n    \"\"\"Ensure numeric value is integer-like and return int, else raise EvalError.\"\"\"\n    if isinstance(x, int):\n        return x\n    if isinstance(x, float):\n        # Accept floats that represent exact integers (within tolerance)\n        if abs(x - round(x)) < 1e-9:\n            return int(round(x))\n        raise EvalError(f\"Expected integer value, got non-integer {x}\")\n    raise EvalError(f\"Expected integer value, got {type(x).__name__}\")\n\n# Unified factorial helper used both by builtin 'factorial' and postfix '!'\ndef _do_factorial(val: Any) -> int:\n    \"\"\"Compute factorial for non-negative integer-like values and raise EvalError for invalid input.\"\"\"\n    n = _ensure_int(val)\n    if n < 0:\n        raise EvalError(\"factorial not defined for negative numbers\")\n    try:\n        return math.factorial(n)\n    except OverflowError:\n        raise EvalError(\"factorial result too large\")\n\n# Builtins registry: map names to callables.\n_BUILTINS: Dict[str, Callable[..., Any]] = {}\n\ndef _register(name: str, func: Callable[..., Any]) -> None:\n    _BUILTINS[name] = func\n\n# Register math functions with safe wrappers.\n_register('sin', lambda x: math.sin(_safe_float(x)))\n_register('cos', lambda x: math.cos(_safe_float(x)))\n_register('tan', lambda x: math.tan(_safe_float(x)))\n_register('asin', lambda x: math.asin(_safe_float(x)))\n_register('acos', lambda x: math.acos(_safe_float(x)))\n_register('atan', lambda x: math.atan(_safe_float(x)))\n_register('sqrt', lambda x: math.sqrt(_safe_float(x)))\n_register('exp', lambda x: math.exp(_safe_float(x)))\n_register('log', lambda *args: math.log(*[_safe_float(a) for a in args]) )\n_register('pow', lambda x, y: math.pow(_safe_float(x), _safe_float(y)))\n_register('abs', lambda x: abs(_safe_float(x)))\n_register('floor', lambda x: math.floor(_safe_float(x)))\n_register('ceil', lambda x: math.ceil(_safe_float(x)))\n# Register unified factorial function\n_register('factorial', _do_factorial)\n\n# Constants are convenient to have as predefined env entries; we also optionally expose names in builtins list\n# but in evaluation variables are read from the environment first (so 'pi' returns numeric value).\n# We do not register 'pi'/'e' as functions to avoid confusion with pi() call semantics.\n_BUILTIN_EXTRA_NAMES = []  # keep builtins dict for functions only\n\n# Provide builtin names list for help/completion (functions only)\n_BUILTIN_NAMES = sorted(_BUILTINS.keys())\n\n# --------------------------\n# Evaluator\n# --------------------------\n\nclass Evaluator:\n    \"\"\"Evaluates AST nodes with environment and builtins mapping.\"\"\"\n\n    def __init__(self):\n        self.env: Dict[str, Any] = {}\n        # Preload numeric constants into environment\n        self.env['pi'] = math.pi\n        self.env['e'] = math.e\n\n    def eval(self, node: ASTNode) -> Any:\n        \"\"\"Evaluate given AST node and return the result or raise EvalError.\"\"\"\n        if isinstance(node, Number):\n            return node.value\n        if isinstance(node, Variable):\n            name = node.name\n            if name in self.env:\n                return self.env[name]\n            # If name exists as a builtin zero-arg function, don't auto-call it here to avoid confusion.\n            # User can call f() explicitly.\n            raise EvalError(f\"Undefined variable: {name}\")\n        if isinstance(node, UnaryOp):\n            val = self.eval(node.operand)\n            op = node.op\n            if op == '+':\n                return +_safe_float(val)\n            if op == '-':\n                return -_safe_float(val)\n            if op == '~':\n                n = _ensure_int(val)\n                return ~n\n            if op == 'not':\n                return not bool(val)\n            raise EvalError(f\"Unknown unary operator: {op}\")\n        if isinstance(node, PostfixOp):\n            op = node.op\n            if op == '!':\n                val = self.eval(node.operand)\n                return _do_factorial(val)\n            raise EvalError(f\"Unknown postfix operator: {op}\")\n        if isinstance(node, BinaryOp):\n            left_val = self.eval(node.left)\n            # logical short-circuit\n            if node.op == 'and':\n                if not bool(left_val):\n                    return False\n                right_val = self.eval(node.right)\n                return bool(right_val)\n            if node.op == 'or':\n                if bool(left_val):\n                    return True\n                right_val = self.eval(node.right)\n                return bool(right_val)\n            right_val = self.eval(node.right)\n            op = node.op\n            try:\n                if op == '+':\n                    if isinstance(left_val, int) and isinstance(right_val, int):\n                        return left_val + right_val\n                    return _safe_float(left_val) + _safe_float(right_val)\n                if op == '-':\n                    if isinstance(left_val, int) and isinstance(right_val, int):\n                        return left_val - right_val\n                    return _safe_float(left_val) - _safe_float(right_val)\n                if op == '*':\n                    if isinstance(left_val, int) and isinstance(right_val, int):\n                        return left_val * right_val\n                    return _safe_float(left_val) * _safe_float(right_val)\n                if op == '/':\n                    denom = _safe_float(right_val)\n                    if denom == 0:\n                        raise EvalError(\"Division by zero\")\n                    return _safe_float(left_val) / denom\n                if op == '%':\n                    if isinstance(left_val, int) and isinstance(right_val, int):\n                        if right_val == 0:\n                            raise EvalError(\"Modulo by zero\")\n                        return left_val % right_val\n                    denom = _safe_float(right_val)\n                    if denom == 0:\n                        raise EvalError(\"Modulo by zero\")\n                    return _safe_float(left_val) % denom\n                if op == '**':\n                    return math.pow(_safe_float(left_val), _safe_float(right_val))\n                if op == '^':\n                    l = _ensure_int(left_val)\n                    r = _ensure_int(right_val)\n                    return l ^ r\n                if op == '<<':\n                    l = _ensure_int(left_val)\n                    r = _ensure_int(right_val)\n                    if r < 0:\n                        raise EvalError(\"negative shift count\")\n                    return l << r\n                if op == '>>':\n                    l = _ensure_int(left_val)\n                    r = _ensure_int(right_val)\n                    if r < 0:\n                        raise EvalError(\"negative shift count\")\n                    return l >> r\n                if op == '&':\n                    l = _ensure_int(left_val)\n                    r = _ensure_int(right_val)\n                    return l & r\n                if op == '|':\n                    l = _ensure_int(left_val)\n                    r = _ensure_int(right_val)\n                    return l | r\n            except EvalError:\n                raise\n            except Exception as e:\n                raise EvalError(f\"Error evaluating binary op {op}: {e}\")\n            raise EvalError(f\"Unknown binary operator: {op}\")\n        if isinstance(node, FuncCall):\n            name = node.name\n            # Look up function in builtins\n            if name in _BUILTINS:\n                func = _BUILTINS[name]\n                # Evaluate arguments before calling\n                args = [self.eval(a) for a in node.args]\n                try:\n                    return func(*args)\n                except TypeError as e:\n                    raise EvalError(f\"Error calling function '{name}': {e}\")\n                except ValueError as e:\n                    raise EvalError(f\"Domain error in function '{name}': {e}\")\n                except EvalError:\n                    raise\n                except Exception as e:\n                    raise EvalError(f\"Error in function '{name}': {e}\")\n            # If user attempts to call a variable, disallow for safety\n            raise EvalError(f\"Unknown function: {name}\")\n        if isinstance(node, Assignment):\n            val = self.eval(node.value)\n            self.env[node.name] = val\n            return val\n        raise EvalError(f\"Unsupported AST node: {type(node).__name__}\")\n\n# --------------------------\n# REPL, History, Help\n# --------------------------\n\nHISTORY_FILE = os.path.expanduser(\"~/.cli_calc_history\")\n\n_HELP_TOPICS: Dict[str, str] = {\n    'general': (\n        \"Calculator REPL help:\\n\"\n        \"Supports arithmetic, bitwise, logical operators, functions, variables, and factorial (!).\\n\"\n        \"Examples:\\n\"\n        \"  x = 3\\n\"\n        \"  2 * -3 -> -6\\n\"\n        \"  -3! -> -(3!) == -6\\n\"\n        \"  --3 -> 3\\n\"\n        \"  sin(pi/2) -> 1\\n\"\n        \"Commands:\\n\"\n        \"  :help, help [topic]    show help\\n\"\n        \"  :vars                  list variables\\n\"\n        \"  :history               show recent history\\n\"\n        \"  :save <file>           save variables to JSON\\n\"\n        \"  :load <file>           load variables from JSON\\n\"\n        \"  :exit                  exit\\n\"\n    ),\n    'operators': (\n        \"Operators and precedence (high -> low):\\n\"\n        \"  postfix: ! (factorial)\\n\"\n        \"  prefix: + - ~ (bitwise not) not/! (logical not)\\n\"\n        \"  exponent: ** (right-assoc)\\n\"\n        \"  * / %\\n\"\n        \"  + -\\n\"\n        \"  << >>\\n\"\n        \"  & ^ |\\n\"\n        \"  and, or\\n\"\n        \"  = (assignment, right-assoc)\\n\"\n        \"Notes:\\n\"\n        \"  - Use '**' for exponentiation (2 ** 3 ** 2 == 2 ** (3 ** 2)).\\n\"\n        \"  - '^' is bitwise XOR.\\n\"\n        \"  - '&&' and '||' are supported as synonyms for 'and' and 'or'.\\n\"\n        \"  - '-' always tokenized as operator; negative literals handled via unary minus (so --3 == 3).\\n\"\n    ),\n    'functions': (\n        \"Built-in functions:\\n\"\n        + \", \".join(_BUILTIN_NAMES) +\n        \"\\nExamples: sin(x), cos(pi), sqrt(2), factorial(5)\\n\"\n    ),\n}\n\ndef show_help(topic: Optional[str] = None) -> str:\n    \"\"\"Return help text for topic or general if None.\"\"\"\n    if not topic:\n        return _HELP_TOPICS['general']\n    key = topic.lower()\n    return _HELP_TOPICS.get(key, f\"No help available for topic '{topic}'\")\n\nclass REPL:\n    \"\"\"Read-Eval-Print Loop for the calculator.\"\"\"\n\n    def __init__(self):\n        self.evaluator = Evaluator()\n        self.history_file = HISTORY_FILE\n        if PROMPT_TOOLKIT_AVAILABLE:\n            self.session = PromptSession(history=FileHistory(self.history_file))\n            self.completer = WordCompleter(_BUILTIN_NAMES, ignore_case=True)\n        else:\n            if 'readline' in globals() and readline is not None:\n                try:\n                    readline.read_history_file(self.history_file)\n                except Exception:\n                    # ignore missing history\n                    pass\n\n    def _save_history(self) -> None:\n        if not PROMPT_TOOLKIT_AVAILABLE and 'readline' in globals() and readline is not None:\n            try:\n                readline.write_history_file(self.history_file)\n            except Exception:\n                pass\n\n    def _process_command(self, line: str) -> Optional[str]:\n        \"\"\"Process commands starting with ':' or 'help'. Returns response string if a command, else None.\n\n        Hardened to avoid shlex.split exceptions and to use simple, predictable parsing.\n        \"\"\"\n        s = line.strip()\n        if not s:\n            return None\n        # Colon commands like :help, :vars, :save file\n        if s.startswith(':'):\n            body = s[1:].lstrip()\n            if body == '':\n                return \"No command specified. Use :help for available commands.\"\n            # split into command and rest (max 1 split)\n            parts = body.split(None, 1)\n            cmd = parts[0]\n            args_str = parts[1] if len(parts) > 1 else ''\n            args = args_str.split() if args_str else []\n            try:\n                return self._run_command(cmd, args)\n            except EOFError:\n                # bubble EOF to caller to exit\n                raise\n            except Exception as e:\n                # Catch unexpected exceptions from commands and return an error string\n                return f\"Command error: {e}\"\n        # help keyword at line start: allow 'help' or 'help topic'\n        if s.lower().startswith('help'):\n            # split into at most two parts to keep topic intact if it contains spaces\n            parts = s.split(None, 1)\n            if len(parts) == 1:\n                return show_help(None)\n            else:\n                # second part is topic, simple whitespace-trimmed\n                topic = parts[1].strip()\n                return show_help(topic)\n        return None\n\n    def _run_command(self, cmd: str, args: List[str]) -> Optional[str]:\n        \"\"\"Execute a REPL colon command. Raises EOFError for exit/quit to allow outer loop to handle shutdown.\"\"\"\n        cmd_lower = cmd.lower()\n        if cmd_lower in {'exit', 'quit'}:\n            raise EOFError()\n        if cmd_lower == 'help':\n            topic = args[0] if args else None\n            return show_help(topic)\n        if cmd_lower == 'vars':\n            items = sorted(self.evaluator.env.items())\n            if not items:\n                return \"(no variables)\"\n            return \"\\n\".join(f\"{k} = {v!r}\" for k, v in items)\n        if cmd_lower == 'history':\n            try:\n                with open(self.history_file, 'r', encoding='utf-8') as f:\n                    all_lines = f.read().splitlines()\n                last = all_lines[-50:]\n                return \"\\n\".join(last)\n            except Exception as e:\n                return f\"Could not read history: {e}\"\n        if cmd_lower == 'save':\n            if not args:\n                return \"Usage: :save <file>\"\n            fname = args[0]\n            try:\n                with open(fname, 'w', encoding='utf-8') as f:\n                    json.dump(self.evaluator.env, f, default=str)\n                return f\"Saved {len(self.evaluator.env)} variables to {fname}\"\n            except Exception as e:\n                return f\"Error saving variables: {e}\"\n        if cmd_lower == 'load':\n            if not args:\n                return \"Usage: :load <file>\"\n            fname = args[0]\n            try:\n                with open(fname, 'r', encoding='utf-8') as f:\n                    data = json.load(f)\n                if not isinstance(data, dict):\n                    return \"Invalid file format\"\n                for k, v in data.items():\n                    self.evaluator.env[k] = v\n                return f\"Loaded {len(data)} variables from {fname}\"\n            except Exception as e:\n                return f\"Error loading variables: {e}\"\n        return f\"Unknown command: {cmd}\"\n\n    def _normalize_logical_symbols(self, text: str) -> str:\n        \"\"\"Stub for potential normalization; lexer already maps &&/|| to 'and'/'or'.\"\"\"\n        return text\n\n    def evaluate_line(self, line: str) -> Tuple[bool, str]:\n        \"\"\"Evaluate a single line (either command or expression). Returns (ok, output).\"\"\"\n        # First check for commands\n        cmd_out = None\n        try:\n            cmd_out = self._process_command(line)\n        except EOFError:\n            # let callers handle EOF by propagating\n            raise\n        except Exception as e:\n            # Catch any command parsing errors\n            return False, f\"Command processing error: {e}\"\n\n        if cmd_out is not None:\n            return True, cmd_out\n\n        text = self._normalize_logical_symbols(line)\n        try:\n            lexer = Lexer(text)\n            tokens = lexer.tokenize()\n            parser = Parser(tokens)\n            ast = parser.parse()\n            result = self.evaluator.eval(ast)\n            return True, repr(result)\n        except (LexerError, ParseError, EvalError) as e:\n            return False, f\"Error: {e}\"\n        except Exception as e:\n            return False, f\"Unhandled error: {e}\"\n\n    def repl_loop(self) -> None:\n        \"\"\"Interactive REPL loop; integrates with prompt_toolkit if available for history and completion.\"\"\"\n        banner = \"Interactive Calculator REPL. Type :help for help. Ctrl-D or :exit to quit.\"\n        print(banner)\n        try:\n            if PROMPT_TOOLKIT_AVAILABLE:\n                while True:\n                    try:\n                        # update completer with builtins and current variables\n                        words = list(_BUILTIN_NAMES) + list(self.evaluator.env.keys())\n                        self.completer = WordCompleter(words, ignore_case=True)\n                        line = self.session.prompt('> ', completer=self.completer)\n                    except KeyboardInterrupt:\n                        print(\"^C\")\n                        continue\n                    except EOFError:\n                        print(\"Exiting.\")\n                        break\n                    if not line.strip():\n                        continue\n                    ok, out = self.evaluate_line(line)\n                    print(out)\n            else:\n                # readline / input fallback\n                while True:\n                    try:\n                        line = input('> ')\n                    except KeyboardInterrupt:\n                        print(\"^C\")\n                        continue\n                    except EOFError:\n                        print(\"Exiting.\")\n                        break\n                    if not line.strip():\n                        continue\n                    ok, out = self.evaluate_line(line)\n                    print(out)\n        finally:\n            self._save_history()\n\n# --------------------------\n# Entry point\n# --------------------------\n\ndef main(argv: Optional[List[str]] = None) -> int:\n    repl = REPL()\n    try:\n        repl.repl_loop()\n    except EOFError:\n        # graceful exit\n        pass\n    return 0\n\nif __name__ == '__main__':\n    raise SystemExit(main())\n```",
    "final_test_report": {
        "passed": true,
        "results": {
            "compilation_success": true,
            "test_results": [
                {
                    "test_name": "test_lexer_tokenization",
                    "passed": true,
                    "description": "Verifies tokenizer correctly produces NUMBER, IDENT, OP, LPAREN, RPAREN, COMMA, EOF tokens for diverse inputs (numbers, identifiers, multi-char ops like '**', '<<', '&&')."
                },
                {
                    "test_name": "test_parser_precedence_and_associativity",
                    "passed": true,
                    "description": "Verifies Pratt parser produces ASTs respecting precedence/associativity rules: postfix '!', prefix unary, right-assoc '**' and '=', and left-assoc arithmetic / bitwise operators."
                },
                {
                    "test_name": "test_evaluator_basic_arithmetic_and_bitwise",
                    "passed": true,
                    "description": "Checks arithmetic operations (+, -, *, /, %, **) and bitwise ops (&, |, ^, <<, >>) evaluate correctly with proper type handling and error messages on invalid inputs (e.g., division by zero)."
                },
                {
                    "test_name": "test_evaluator_postfix_factorial_and_function_factorial",
                    "passed": true,
                    "description": "Ensures postfix '!' and builtin factorial(...) are unified (same semantics) and validate integer/non-negative operands, returning the same results and consistent error messages."
                },
                {
                    "test_name": "test_repl_evaluate_line_success_and_commands",
                    "passed": true,
                    "description": "Verifies REPL.evaluate_line handles expression evaluation and REPL commands (:help, help, :vars, :save/:load usage) robustly and returns expected outputs without raising unexpected exceptions."
                },
                {
                    "test_name": "test_complex_expression_evaluation",
                    "passed": true,
                    "description": "Integration-style test combining prefix/postfix/unary chains, function calls, bitwise and logical operators to ensure parser + evaluator handle complex inputs correctly."
                }
            ],
            "issues": [
                {
                    "type": "suggestion",
                    "severity": "minor",
                    "description": "Constants 'pi' and 'e' are preloaded into the environment but are not included in the builtin function name list used for autocompletion/help. This may confuse users who expect 'pi' listed with function names.",
                    "location": "builtins/env initialization (_BUILTINS, Evaluator.__init__)",
                    "fix_suggestion": "Include constants in the helper name list used for completion/help. For example, define _NAME_COMPLETION = sorted(list(_BUILTINS.keys()) + ['pi','e']) and use that for the completer and the functions help list. Keep 'pi' and 'e' as env values (not callables) but surface them in completions and help."
                },
                {
                    "type": "suggestion",
                    "severity": "minor",
                    "description": "Parser disallows constructs like (expr)(args) \u2014 i.e., calling the result of an expression. This is a deliberate design choice for safety, but may surprise advanced users who expect function values or lambdas to be callable. Currently only Variable followed by '(' is treated as a FuncCall.",
                    "location": "Parser.parse_expression (function call handling)",
                    "fix_suggestion": "If you want to support calling any expression result (e.g., higher-order functions), adjust the parser to allow LPAREN after any expression and evaluate callables only if the evaluated left value is callable. Example change: when encountering LPAREN after any left, parse arguments then create a CallOnExpr node; Evaluator would then eval the left and if callable, call it with evaluated args, otherwise raise EvalError. Keep this optional and gated behind an explicit design decision for safety."
                },
                {
                    "type": "performance",
                    "severity": "minor",
                    "description": "Using math.pow for exponentiation always produces floats; large integer powers might be better expressed using the Python '**' operator to preserve big-int results when operands are integers.",
                    "location": "Evaluator BinaryOp handling ('**' case)",
                    "fix_suggestion": "If both operands are integer-like and the result is expected to be integer, do integer exponentiation: if left and right evaluate to ints (or exact-int floats), compute left ** right (with _ensure_int for exponent if desired). Otherwise fallback to math.pow or float pow. For example:\nif isinstance(left_val, int) and isinstance(right_val, int):\n    return left_val ** right_val\nelse:\n    return math.pow(_safe_float(left_val), _safe_float(right_val))\nThis preserves integer semantics for integer exponents and avoids float conversion when unnecessary."
                },
                {
                    "type": "suggestion",
                    "severity": "minor",
                    "description": "History file defaults to ~/.cli_calc_history. In environments where HOME is not set or is read-only, read/write may fail (caught currently), but tests or users may prefer configurable path.",
                    "location": "HISTORY_FILE constant",
                    "fix_suggestion": "Allow overriding the history file via environment variable or REPL constructor parameter (e.g., CLI_ARG or env var CLI_CALC_HISTORY). Example: HISTORY_FILE = os.environ.get('CLI_CALC_HISTORY', os.path.expanduser('~/.cli_calc_history')). Document fallback behavior in README."
                },
                {
                    "type": "security",
                    "severity": "minor",
                    "description": "Builtins are whitelisted and no eval/exec is used \u2014 this is good. However, when saving/loading env via :save/:load, arbitrary objects serialized as strings could be reloaded into the environment with potential type mismatches (not arbitrary code execution, but surprising values).",
                    "location": "REPL._run_command save/load",
                    "fix_suggestion": "When loading a saved JSON, validate each loaded value type (only allow numbers and booleans, maybe strings) before injecting into evaluator.env. For example, if you only support numeric variables, skip non-number entries or raise an informative error. Alternatively, store metadata with types in the saved JSON to enable safer restoration."
                }
            ],
            "test_coverage": "unknown (not measured by this run)",
            "overall_assessment": "Very good. The revised implementation compiles cleanly and all automated tests passed (100%). The code is well-structured: lexer, parser, AST, evaluator, builtins and REPL are clearly separated. The fixes you implemented (unified factorial, hardened command parsing, explicit prefix/infix/postfix precedence maps) resolved earlier issues and improved robustness. The suggestions above are minor refinements (completion/listing of constants, optional support for calling expressions, integer-preserving exponentiation, configurable history path, and safer load validation) to consider for usability and correctness edge-cases.",
            "pass_percentage": 100.0,
            "passed_count": 30,
            "failed_count": 0,
            "total_count": 30
        }
    },
    "iterations_required": 2,
    "success": true
}